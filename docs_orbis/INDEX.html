<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ORBIS-Modellfabrik - Dokumentationsindex</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; margin: 0; padding: 20px; background: #f5f5f5; }
        .container { max-width: 1200px; margin: 0 auto; background: white; padding: 30px; border-radius: 10px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
        h1 { color: #2c3e50; border-bottom: 3px solid #3498db; padding-bottom: 10px; }
        .search-box { margin: 20px 0; padding: 15px; background: #ecf0f1; border-radius: 5px; }
        .search-box input { width: 100%; padding: 10px; border: 1px solid #bdc3c7; border-radius: 5px; font-size: 16px; }
        .category { margin: 30px 0; }
        .category h2 { color: #34495e; background: #ecf0f1; padding: 10px; border-radius: 5px; }
        .documents { display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 15px; margin-top: 15px; }
        .document { background: #f8f9fa; padding: 15px; border-radius: 5px; border-left: 4px solid #3498db; }
        .document h3 { margin: 0 0 10px 0; color: #2c3e50; }
        .document p { margin: 5px 0; color: #7f8c8d; font-size: 14px; }
        .document a { color: #3498db; text-decoration: none; }
        .document a:hover { text-decoration: underline; }
        .keywords { margin-top: 10px; }
        .keyword { display: inline-block; background: #e74c3c; color: white; padding: 2px 8px; border-radius: 12px; font-size: 12px; margin: 2px; }
        .stats { background: #2ecc71; color: white; padding: 15px; border-radius: 5px; margin-bottom: 20px; }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ“š ORBIS-Modellfabrik - Dokumentationsindex</h1>
        
        <div class="stats">
            <strong>ğŸ“Š Statistiken:</strong>
            50 Dokumente in 7 Kategorien
            | Generiert am 12.09.2025 12:10
        </div>
        
        <div class="search-box">
            <input type="text" id="searchInput" placeholder="ğŸ” Dokumentation durchsuchen..." onkeyup="searchDocuments()">
        </div>
        
        <div id="categories">

            <div class="category">
                <h2>ğŸ“‚ analysis (8 Dokumente)</h2>
                <div class="documents">

                    <div class="document" data-searchable="umfassende workflow-analyse: wareneingang, auftrag und ai-not-ok sessions ğŸ“‹ Ã¼bersicht diese umfassende analyse untersucht alle workflow-typen der aps-modellfabrik: - wareneingang rot, weiss, blau - werkstÃ¼ck-eingang und lagerung - auftrag rot, weiss, blau - produktionsauftrÃ¤ge mit verarbeitung - ai-not-ok rot, weiss, blau - produktionsauftrÃ¤ge mit ai-prÃ¼fung ziel: vollstÃ¤ndiges verstÃ¤ndnis der workflows fÃ¼r template message entwicklung. ğŸ¯ analysierte sessions wareneingang sessions 9 - aps_persistent_traffic_wareneingang-rot_1.db bis wareneingang-rot_3.db - aps_persistent_traffic_wareneingang-weiss_1.db bis wareneingang-weiss_3.db - aps_persistent_traffic_wareneingang-blau_1.db bis wareneingang-blau_3.db auftrag sessions 3 - aps_persistent_traffic_auftrag-rot_1.db - aps_persistent_traffic_auftrag-weiss_1.db - aps_persistent_traffic_auftrag-blau_1.db ai-not-ok sessions 3 - aps_persistent_traffic_ai-not-ok-rot_1.db - aps_persistent_traffic_ai-not-ok-weiss_1.db - aps_persistent_traffic_ai-">
                        <h3><a href="analysis/comprehensive-workflow-analysis.md">Umfassende Workflow-Analyse: Wareneingang, Auftrag und AI-not-ok Sessions</a></h3>
                        <p>Diese umfassende Analyse untersucht alle Workflow-Typen der APS-Modellfabrik:</p>
                        <p><strong>ğŸ“ Pfad:</strong> analysis/comprehensive-workflow-analysis.md</p>
                        <p><strong>ğŸ“Š GrÃ¶ÃŸe:</strong> 12,206 Bytes | <strong>WÃ¶rter:</strong> 1400</p>
                        <div class="keywords"></div>
                    </div>

                    <div class="document" data-searchable="ğŸ“ dokumentation update summary - commit 19.08.2025 ğŸ—‘ï¸ gelÃ¶schte dateien - docs_orbis/copilot_push_test.md - test-datei, nicht relevant - docs_orbis/push_test.md - test-datei, nicht relevant - docs_orbis/chat.txt - temporÃ¤re chat-datei ğŸ“ aktualisierte dokumentation 1. docs_orbis/mqtt/mqtt-control-summary.md Ã¤nderungen: - âœ… neue befehle hinzugefÃ¼gt : mill mill , drill drill , dps input_rgb, rgb_nfc - ğŸš¨ kritisches problem : order-id management als prioritÃ¤t markiert - ğŸ“‹ next steps : order-id management als kritische phase 1 definiert - ğŸ” important findings : orderupdateid inkrementierung dokumentiert 2. docs_orbis/analysis/mqtt-template-testing-strategie.md Ã¤nderungen: - ğŸ¯ strategie geÃ¤ndert : von "hybrid-ansatz" zu "order-id fokus" - ğŸš¨ phase 1 : order-id management als kritische prioritÃ¤t - ğŸ“Š testing-plan : workflowordermanager als erste phase - ğŸ“ fazit : order-id management als essentiell markiert 3. docs_orbis/analysis/mqtt-template-testing-ergebnisse.md Ã¤nderungen: - ğŸ“Š neue templates ">
                        <h3><a href="analysis/documentation-update-summary.md">ğŸ“ Dokumentation Update Summary - Commit 19.08.2025</a></h3>
                        <p>- `docs_orbis/copilot_push_test.md` - Test-Datei, nicht relevant</p>
                        <p><strong>ğŸ“ Pfad:</strong> analysis/documentation-update-summary.md</p>
                        <p><strong>ğŸ“Š GrÃ¶ÃŸe:</strong> 2,828 Bytes | <strong>WÃ¶rter:</strong> 313</p>
                        <div class="keywords"></div>
                    </div>

                    <div class="document" data-searchable="ğŸ“„ fischertechnik aps-dokumentation analyse ğŸ“‹ dokumentations-Ã¼bersicht dokument: dokumentation_aps_de-02-2025.rtf version: 4.0 model revision: 1.x datum: februar 2025 sprache: deutsch ğŸ¯ wichtige erkenntnisse aus der dokumentation ğŸ­ system-architektur zentrale komponenten: - raspberry pi 4b : herzstÃ¼ck des systems mit zentraler steuerungssoftware - mqtt-broker : port 1883 auf 192.168.0.100 default/default - node-red : port 1880 auf 192.168.0.100 gateway zwischen opc-ua und mqtt - router : tp-link tl-wr902ac 192.168.0.1, admin/admin1 modul-controller: - txt 4.0 controller : kommuniziert via mqtt mit zentraler steuerung - sps s7-1200 : individueller opc-ua server pro modul ğŸ“¡ netzwerk-konfiguration ip-adressen der module: mill: 192.168.0.40-45 âœ… in unserer aps vorhanden drill: 192.168.0.50-55 âœ… in unserer aps vorhanden oven: 192.168.0.60-65 âŒ optional - nicht in unserer aps aiqs: 192.168.0.70-75 âœ… in unserer aps vorhanden hbw: 192.168.0.80-83 âœ… in unserer aps vorhanden dps: 192.168.0.90 âœ… i">
                        <h3><a href="analysis/fischertechnik-dokumentation-analyse.md">ğŸ“„ Fischertechnik APS-Dokumentation Analyse</a></h3>
                        <p>**Dokument:** `Dokumentation_APS_DE-02-2025.rtf`</p>
                        <p><strong>ğŸ“ Pfad:</strong> analysis/fischertechnik-dokumentation-analyse.md</p>
                        <p><strong>ğŸ“Š GrÃ¶ÃŸe:</strong> 5,979 Bytes | <strong>WÃ¶rter:</strong> 645</p>
                        <div class="keywords"></div>
                    </div>

                    <div class="document" data-searchable="ğŸš¨ mqtt order-id management strategie ğŸ“‹ kritisches problem identifiziert ğŸš¨ root cause: "orderupdateid not valid" fehler in mqtt response: { "actionstate": { "state": "failed", "command": "pick" }, "errors": { "errortype": "validation", "errormessage": "orderupdateid not valid" } } ğŸ” problem-analyse: 1. order-id : wird korrekt generiert uuid 2. orderupdateid : bleibt immer 1 fÃ¼r alle commands 3. workflow-sequenz : pick â†’ process â†’ drop benÃ¶tigt inkrementelle orderupdateid 4. aps-erwartung : orderupdateid muss fÃ¼r sequenzielle commands steigen 1, 2, 3... --- ğŸ¯ lÃ¶sungsstrategie: workflowordermanager 1. workflowordermanager klasse python import uuid from datetime import datetime from typing import dict, list, optional class workflowordermanager: def __init__ self : self.active_workflows: dict str, dict = {} self.workflow_history: list dict = def start_workflow self, module: str, commands: list str , workpiece_type: str = "white" -> str: """startet einen neuen workflow und gibt orderid zurÃ¼c">
                        <h3><a href="analysis/mqtt-order-id-management-strategie.md">ğŸš¨ MQTT ORDER-ID Management Strategie</a></h3>
                        <p>Fehler in MQTT Response:</p>
                        <p><strong>ğŸ“ Pfad:</strong> analysis/mqtt-order-id-management-strategie.md</p>
                        <p><strong>ğŸ“Š GrÃ¶ÃŸe:</strong> 10,293 Bytes | <strong>WÃ¶rter:</strong> 925</p>
                        <div class="keywords"></div>
                    </div>

                    <div class="document" data-searchable="ğŸ“Š mqtt-session-analyse ergebnisse ğŸ¯ Ã¼bersicht der systematischen analyse datum: 19. august 2025 analysierte sessions: 18 sessions gesamt-nachrichten: 13.193 mqtt-nachrichten --- ğŸ“‹ session-kategorien und ergebnisse 1. ğŸ­ wareneingang sessions 9 sessions - gesamt-nachrichten: 4.170 - order-ids: 37 eindeutige ids - durchschnitt pro session: ~463 nachrichten, ~4 order-ids varianz-analyse: - blau: 3 sessions 1.487 nachrichten - rot: 3 sessions 1.293 nachrichten - weiÃŸ: 3 sessions 1.390 nachrichten konsistente muster: - âœ… alle sessions haben 4-5 order-ids - âœ… keine status-updates erkannt modul-status-monitoring fehlt - âœ… viele command-sequenzen 421-545 pro session - âš ï¸ error-nachrichten: 55-121 pro session 2. ğŸ“¦ auftrag sessions 3 sessions - gesamt-nachrichten: 3.212 - order-ids: 8 eindeutige ids - durchschnitt pro session: ~1.071 nachrichten, ~2.7 order-ids ergebnisse: - blau: 1.168 nachrichten, 4 order-ids - rot: 1.045 nachrichten, 1 order-id âš ï¸ - weiÃŸ: 999 nachrichten, 3 order-ids kritische">
                        <h3><a href="analysis/mqtt-session-analyse-ergebnisse.md">ğŸ“Š MQTT-Session-Analyse Ergebnisse</a></h3>
                        <p>**Datum:** 19. August 2025</p>
                        <p><strong>ğŸ“ Pfad:</strong> analysis/mqtt-session-analyse-ergebnisse.md</p>
                        <p><strong>ğŸ“Š GrÃ¶ÃŸe:</strong> 9,655 Bytes | <strong>WÃ¶rter:</strong> 1115</p>
                        <div class="keywords"></div>
                    </div>

                    <div class="document" data-searchable="ğŸ“Š mqtt-session-analyse plan ğŸ¯ analyse-ziel systematische analyse der mqtt-nachrichten wÃ¤hrend spezifischer workflows, um muster und abhÃ¤ngigkeiten zu identifizieren, die die mqtt-command-probleme verursachen. ğŸ“‹ geplante mqtt-sessions session 1: wareneingang rot, weiÃŸ, blau ziel : verstehen der mqtt-nachrichten beim wareneingang verschiedener werkstÃ¼ck-typen workflow-schritte: 1. werkstÃ¼ck rot in wareneingang platzieren 2. mqtt-session aufnehmen wÃ¤hrend des gesamten prozesses 3. werkstÃ¼ck weiÃŸ in wareneingang platzieren 4. mqtt-session aufnehmen wÃ¤hrend des gesamten prozesses 5. werkstÃ¼ck blau in wareneingang platzieren 6. mqtt-session aufnehmen wÃ¤hrend des gesamten prozesses session-labels: - wareneingang-rot_1 , wareneingang-rot_2 , wareneingang-rot_3 - wareneingang-weiss_1 , wareneingang-weiss_2 , wareneingang-weiss_3 - wareneingang-blau_1 , wareneingang-blau_2 , wareneingang-blau_3 zu analysierende aspekte: - order-id generierung : wie werden eindeutige order-ids erstellt? - timing-">
                        <h3><a href="analysis/mqtt-session-analyse-plan.md">ğŸ“Š MQTT-Session-Analyse Plan</a></h3>
                        <p>Systematische Analyse der MQTT-Nachrichten wÃ¤hrend spezifischer Workflows, um Muster und AbhÃ¤ngigkeiten zu identifizieren, die die MQTT-Command-Probleme verursachen.</p>
                        <p><strong>ğŸ“ Pfad:</strong> analysis/mqtt-session-analyse-plan.md</p>
                        <p><strong>ğŸ“Š GrÃ¶ÃŸe:</strong> 7,923 Bytes | <strong>WÃ¶rter:</strong> 844</p>
                        <div class="keywords"></div>
                    </div>

                    <div class="document" data-searchable="ğŸ“„ fischertechnik pdf-analyse ergebnisse ğŸ“‹ analyse-status dokumentation: dokumentation_aps_de-02-2025.rtf format: rtf rich text format - erfolgreich analysiert status: âœ… vollstÃ¤ndig analysiert - alle wichtigen informationen extrahiert ğŸ¯ wichtige entdeckungen 1. system-architektur bestÃ¤tigt - âœ… raspberry pi 4b als zentrale steuerungseinheit - âœ… mqtt-broker auf port 1883 192.168.0.100 - âœ… node-red gateway auf port 1880 fÃ¼r opc-ua â†” mqtt Ã¼bersetzung - âœ… tp-link router 192.168.0.1 fÃ¼r netzwerk-management 2. modul-ip-adressen validiert mill: 192.168.0.40-45 âœ… bestÃ¤tigt drill: 192.168.0.50-55 âœ… bestÃ¤tigt oven: 192.168.0.60-65 ğŸ”„ neu entdeckt aiqs: 192.168.0.70-75 âœ… bestÃ¤tigt hbw: 192.168.0.80-83 âœ… bestÃ¤tigt dps: 192.168.0.90 âœ… bestÃ¤tigt 3. technische standards identifiziert - vda5050 : standard fÃ¼r fts-kommunikation - opc-ua : fÃ¼r sps-module port 4840 - mqtt : fÃ¼r txt 4.0 controller - node-red : gateway zwischen protokollen 4. zugangsdaten dokumentiert - mqtt : default/default - node-red : htt">
                        <h3><a href="analysis/pdf-analyse-ergebnisse.md">ğŸ“„ Fischertechnik PDF-Analyse Ergebnisse</a></h3>
                        <p>**Dokumentation:** `Dokumentation_APS_DE-02-2025.rtf`</p>
                        <p><strong>ğŸ“ Pfad:</strong> analysis/pdf-analyse-ergebnisse.md</p>
                        <p><strong>ğŸ“Š GrÃ¶ÃŸe:</strong> 4,641 Bytes | <strong>WÃ¶rter:</strong> 510</p>
                        <div class="keywords"></div>
                    </div>

                    <div class="document" data-searchable="ğŸ“¹ session-recording guide ğŸ¯ praktische anleitung fÃ¼r mqtt-session-aufnahme vorbereitung 1. aps-system vorbereiten - alle module einschalten - mqtt-broker lÃ¤uft 192.168.0.100:1883 - werkstÃ¼cke bereitstellen rot, weiÃŸ, blau 2. session-logger vorbereiten bash cd /users/oliver/projects/orbis-modellfabrik session-recording workflow schritt 1: session starten bash session-logger starten python src_orbis/mqtt/loggers/aps_session_logger.py --session-label wareneingang-rot_1 --auto-start schritt 2: workflow durchfÃ¼hren - werkstÃ¼ck rot in wareneingang platzieren - gesamten prozess beobachten - auf fehler achten und notieren schritt 3: session beenden - "q" drÃ¼cken um session zu stoppen - session-db prÃ¼fen in data/mqtt-data/sessions/ ğŸ“‹ session-plan flexibel - basis + varianz bei bedarf phase 1: wareneingang basis + varianz bei bedarf bash basis-sessions 1x pro szenario python src_orbis/mqtt/loggers/aps_session_logger.py --session-label wareneingang-rot --auto-start python src_orbis/mqtt/loggers/a">
                        <h3><a href="analysis/session-recording-guide.md">ğŸ“¹ Session-Recording Guide</a></h3>
                        <p>1. **APS-System vorbereiten**</p>
                        <p><strong>ğŸ“ Pfad:</strong> analysis/session-recording-guide.md</p>
                        <p><strong>ğŸ“Š GrÃ¶ÃŸe:</strong> 6,970 Bytes | <strong>WÃ¶rter:</strong> 568</p>
                        <div class="keywords"><span class="keyword">guide</span></div>
                    </div>

                </div>
            </div>

            <div class="category">
                <h2>ğŸ“‚ archive (4 Dokumente)</h2>
                <div class="documents">

                    <div class="document" data-searchable="chat-zusammenfassung fÃ¼r neue session ğŸ¯ aktueller projektstand september 2025 âœ… abgeschlossene arbeiten 1. dashboard v3.3.0 entwicklung - neue produktionsplanung-features implementiert 2. shopfloor 3x4-grid system - vollstÃ¤ndig implementiert mit intersection1-4 ids 3. fts route generator - yaml â†’ mqtt message generator fÃ¼r fahrerloses transport system 4. produktkatalog - blau, weiÃŸ, rot produkte mit fertigungsauftrÃ¤gen 5. messagegenerator integration - alle neuen features nutzen das zentrale konzept 6. umfassende tests - unit tests fÃ¼r alle neuen komponenten ğŸ”§ aktuelles problem: windows alluppercase dateinamen - problem : auf windows system wurden dateien in alluppercase abgelegt - lokale dateien : alle in lowercase connection.yml, state.yml, etc. - windows dateien : vermutlich connection.yml, state.yml, etc. - auswirkung : mÃ¶gliche kompatibilitÃ¤tsprobleme bei der Ã¼bertragung ğŸ“ wichtige dateien und strukturen src_orbis/omf/config/ â”œâ”€â”€ message_templates/templates/ â”‚ â”œâ”€â”€ ccu/ control.yml">
                        <h3><a href="archive/CHAT_SUMMARY_FOR_NEW_SESSION.md">Chat-Zusammenfassung fÃ¼r neue Session</a></h3>
                        <p>1. **Dashboard v3.3.0 Entwicklung** - Neue Produktionsplanung-Features implementiert</p>
                        <p><strong>ğŸ“ Pfad:</strong> archive/CHAT_SUMMARY_FOR_NEW_SESSION.md</p>
                        <p><strong>ğŸ“Š GrÃ¶ÃŸe:</strong> 2,593 Bytes | <strong>WÃ¶rter:</strong> 289</p>
                        <div class="keywords"></div>
                    </div>

                    <div class="document" data-searchable="commit summary: sequenz-steuerung implementation ğŸ¯ commit-ziel vollstÃ¤ndige implementierung der sequenz-steuerung mit automatischer mqtt-nachrichten-ausfÃ¼hrung, die identisch mit der factory-steuerung ist. ğŸ“‹ geÃ¤nderte dateien neue dateien - src_orbis/omf/dashboard/components/steering_sequence.py - dashboard-integration - src_orbis/omf/tools/sequence_ui.py - ui-komponenten - src_orbis/omf/tools/sequence_executor.py - haupt-engine - src_orbis/omf/tools/workflow_order_manager.py - order-management - src_orbis/omf/config/sequence_definitions/aiqs_sequence.py - aiqs-sequenz - tests_orbis/test_sequence_integration.py - integrationstests - tests_orbis/test_sequence_vs_factory_steering.py - validierungstests - tests_orbis/test_sequence_variable_resolution.py - variable-resolution tests - tests_orbis/test_comprehensive_sequence_errors.py - fehlerbehandlung tests - docs_orbis/sequence-control-implementation-2025-01.md - dokumentation geÃ¤nderte dateien - src_orbis/omf/dashboard/components/steerin">
                        <h3><a href="archive/COMMIT_SUMMARY_SEQUENCE_CONTROL.md">Commit Summary: Sequenz-Steuerung Implementation</a></h3>
                        <p>VollstÃ¤ndige Implementierung der Sequenz-Steuerung mit automatischer MQTT-Nachrichten-AusfÃ¼hrung, die identisch mit der Factory-Steuerung ist.</p>
                        <p><strong>ğŸ“ Pfad:</strong> archive/COMMIT_SUMMARY_SEQUENCE_CONTROL.md</p>
                        <p><strong>ğŸ“Š GrÃ¶ÃŸe:</strong> 5,181 Bytes | <strong>WÃ¶rter:</strong> 530</p>
                        <div class="keywords"></div>
                    </div>

                    <div class="document" data-searchable="import-pfad-probleme systematisch lÃ¶sen problem - black formatiert relative imports zurÃ¼ck, aber die module existieren nicht an den erwarteten orten - modulenotfounderror bei tests und imports - pre-commit hooks schlagen fehl wegen import-problemen lÃ¶sung: projekt als installierbares paket konfigurieren âœ… schritt 1: pyproject.toml erweitert - setuptools-konfiguration hinzugefÃ¼gt - pytest-konfiguration hinzugefÃ¼gt - isort known_first_party konfiguriert ğŸ”„ schritt 2: editable installation bash pip install -e . zweck: macht src_orbis als top-level-package verfÃ¼gbar, damit import src_orbis.omf... Ã¼berall funktioniert ğŸ”„ schritt 3: pre-commit-config.yaml anpassen yaml - id: pytest name: pytest entry: python -m pytest -q language: system pass_filenames: false â¬…ï¸ kritisch! stages: pre-commit zweck: pytest lÃ¤uft ohne dateiliste, importiert nicht versehentlich streamlit-dateien ğŸ”„ schritt 4: sys.path manipulationen entfernen - suche nach sys.path.append in allen dateien - entferne diese, da sie na">
                        <h3><a href="archive/IMPORT_FIX_TODO.md">Import-Pfad-Probleme systematisch lÃ¶sen</a></h3>
                        <p>- Black formatiert relative Imports zurÃ¼ck, aber die Module existieren nicht an den erwarteten Orten</p>
                        <p><strong>ğŸ“ Pfad:</strong> archive/IMPORT_FIX_TODO.md</p>
                        <p><strong>ğŸ“Š GrÃ¶ÃŸe:</strong> 2,390 Bytes | <strong>WÃ¶rter:</strong> 282</p>
                        <div class="keywords"></div>
                    </div>

                    <div class="document" data-searchable="orbis modellfabrik dashboard ein umfassendes dashboard fÃ¼r die orbis modellfabrik mit mqtt-nachrichtenÃ¼berwachung und replay-funktionalitÃ¤t. ğŸ¯ projekt-ziel entwicklung einer eigenen steuerungsanwendung fÃ¼r die aps fischertechnik miniatur-fabrik durch analyse der bestehenden nachrichten-kommunikation. ğŸ­ aps-fischertechnik system - reale miniatur-fabrik mit verschiedenen modulen - software zur steuerung der fabrik-prozesse wareneingang, produktion nach bestellung - ziel: verstÃ¤ndnis der funktionsweise fÃ¼r eigene steuerungsanwendung ğŸš€ entwicklungsphasen 1. session-rekording âœ… - aufnahme der mqtt-nachrichten-strÃ¶me 2. session-analyse ğŸ”„ - semantik und funktionsweise verstehen 3. steuerungs-entwicklung ğŸ“‹ - omf dashboard fÃ¼r fabrik-steuerung > ğŸ“– detaillierte projekt-Ã¼bersicht: project_overview.md docs_orbis/project_overview.md ğŸ“‹ entwicklungsregeln > ğŸ¯ wichtig: bevor sie mit der entwicklung beginnen, lesen sie die entwicklungsregeln docs_orbis/development_rules.md ! - import-standards: nur abs">
                        <h3><a href="archive/README_current.md">ORBIS Modellfabrik Dashboard</a></h3>
                        <p>Ein umfassendes Dashboard fÃ¼r die ORBIS Modellfabrik mit MQTT-NachrichtenÃ¼berwachung und Replay-FunktionalitÃ¤t.</p>
                        <p><strong>ğŸ“ Pfad:</strong> archive/README_current.md</p>
                        <p><strong>ğŸ“Š GrÃ¶ÃŸe:</strong> 6,886 Bytes | <strong>WÃ¶rter:</strong> 685</p>
                        <div class="keywords"><span class="keyword">overview</span></div>
                    </div>

                </div>
            </div>

            <div class="category">
                <h2>ğŸ“‚ guides (13 Dokumente)</h2>
                <div class="documents">

                    <div class="document" data-searchable="mqtt integration guide ğŸ“‹ overview das omf dashboard verwendet die per-topic-buffer architektur fÃ¼r mqtt-nachrichtenverarbeitung. diese moderne architektur kombiniert das mqtt-singleton pattern mit effizienten per-topic-buffers fÃ¼r optimale performance und einfachheit. âœ… aktuelle mqtt architektur 1. mqtt-singleton pattern - eine mqtt-client-instanz pro streamlit-session - zentraler zugriff Ã¼ber st.session_state "mqtt_client" - automatische verbindung beim dashboard-start - umgebungswechsel live/mock/replay ohne verbindungsabbruch 2. per-topic-buffer system - topic-spezifische buffer fÃ¼r jede mqtt-subscription - automatische nachrichtensammlung in separaten buffers - effiziente verarbeitung ohne message-processor overhead - direkte buffer-zugriffe fÃ¼r optimale performance 3. hybrid-architektur fÃ¼r publishing - messagegenerator fÃ¼r payload-erstellung - session state fÃ¼r preview/edit-funktionalitÃ¤t - mqttgateway fÃ¼r finales publishing - workflowordermanager fÃ¼r orderid/orderupdateid verwal">
                        <h3><a href="guides/communication/MQTT_INTEGRATION_GUIDE.md">MQTT Integration Guide</a></h3>
                        <p>Das **OMF Dashboard** verwendet die **Per-Topic-Buffer Architektur** fÃ¼r MQTT-Nachrichtenverarbeitung. Diese moderne Architektur kombiniert das **MQTT-Singleton Pattern** mit effizienten **Per-Topic-B...</p>
                        <p><strong>ğŸ“ Pfad:</strong> guides/communication/MQTT_INTEGRATION_GUIDE.md</p>
                        <p><strong>ğŸ“Š GrÃ¶ÃŸe:</strong> 3,734 Bytes | <strong>WÃ¶rter:</strong> 365</p>
                        <div class="keywords"><span class="keyword">guide</span></div>
                    </div>

                    <div class="document" data-searchable="dashboard icon integration âš ï¸ veraltet - aps dashboard Ã¼bersicht âš ï¸ veraltet das aps dashboard wurde mit umfassenden icon-features erweitert, um eine intuitive und visuell ansprechende benutzeroberflÃ¤che zu bieten. âš ï¸ hinweis: diese dokumentation bezieht sich auf das veraltete aps dashboard. die icon-integration wurde in das neue omf dashboard Ã¼bernommen. implementierte features ğŸ¨ icon-system module icons - mill: âš™ï¸ gear - drill: ğŸ”© nut&bolt - hbw: ğŸ¬ department store - aiqs: ğŸ¤– robot - dps: ğŸ“¦ package - fts: ğŸš— car - chrg: ğŸ”‹ battery - oven: ğŸ”¥ fire status icons - available: âœ… - busy: âš ï¸ - blocked: âŒ - charging: âš¡ - transport: ğŸš— - maintenance: ğŸ”§ - idle: ğŸ˜´ - ready: ğŸ¯ system icons - rpi: ğŸ–¥ï¸ - txt: ğŸ® - router: ğŸŒ - mqtt: ğŸ“¡ ğŸ“ integration module overview - emoji-icons in der modul-tabelle - status-icons fÃ¼r activity status - connection status mit icons mqtt control - module-headers mit icons - status-anzeigen mit erweiterten icons - button-icons fÃ¼r befehle sidebar - orbis logo integration - mqtt ">
                        <h3><a href="guides/communication/mqtt/dashboard-icon-integration.md">Dashboard Icon Integration âš ï¸ **VERALTET - APS Dashboard**</a></h3>
                        <p>Das APS Dashboard wurde mit umfassenden Icon-Features erweitert, um eine intuitive und visuell ansprechende BenutzeroberflÃ¤che zu bieten.</p>
                        <p><strong>ğŸ“ Pfad:</strong> guides/communication/mqtt/dashboard-icon-integration.md</p>
                        <p><strong>ğŸ“Š GrÃ¶ÃŸe:</strong> 2,055 Bytes | <strong>WÃ¶rter:</strong> 252</p>
                        <div class="keywords"></div>
                    </div>

                    <div class="document" data-searchable="ğŸ”— mqtt integration - omf dashboard ğŸ“‹ overview das omf dashboard verwendet die per-topic-buffer architektur fÃ¼r mqtt-nachrichtenverarbeitung. diese moderne architektur kombiniert das mqtt-singleton pattern mit effizienten per-topic-buffers fÃ¼r optimale performance und einfachheit. âœ… aktuelle mqtt architektur 1. mqtt-singleton pattern - eine mqtt-client-instanz pro streamlit-session - zentraler zugriff Ã¼ber st.session_state "mqtt_client" - automatische verbindung beim dashboard-start - umgebungswechsel live/mock/replay ohne verbindungsabbruch 2. per-topic-buffer system - topic-spezifische buffer fÃ¼r jede mqtt-subscription - automatische nachrichtensammlung in separaten buffers - effiziente verarbeitung ohne message-processor overhead - direkte buffer-zugriffe fÃ¼r optimale performance 3. hybrid-architektur fÃ¼r publishing - messagegenerator fÃ¼r payload-erstellung - session state fÃ¼r preview/edit-funktionalitÃ¤t - mqttgateway fÃ¼r finales publishing - workflowordermanager fÃ¼r orderid/orderupd">
                        <h3><a href="guides/communication/mqtt/dashboard-mqtt-integration.md">ğŸ”— MQTT Integration - OMF Dashboard</a></h3>
                        <p>Das **OMF Dashboard** verwendet die **Per-Topic-Buffer Architektur** fÃ¼r MQTT-Nachrichtenverarbeitung. Diese moderne Architektur kombiniert das **MQTT-Singleton Pattern** mit effizienten **Per-Topic-B...</p>
                        <p><strong>ğŸ“ Pfad:</strong> guides/communication/mqtt/dashboard-mqtt-integration.md</p>
                        <p><strong>ğŸ“Š GrÃ¶ÃŸe:</strong> 11,205 Bytes | <strong>WÃ¶rter:</strong> 1088</p>
                        <div class="keywords"></div>
                    </div>

                    <div class="document" data-searchable="ğŸ¯ mqtt control summary - fischertechnik aps ğŸ“‹ executive summary we have successfully analyzed, tested, and documented the mqtt control capabilities of the fischertechnik aps model factory. through systematic testing, we discovered working mqtt messages and created a comprehensive library for reliable module control. âœ… key achievements 1. working mqtt messages discovered - âœ… drill pick command : successfully tested and working - âœ… message library created : reusable templates for all modules - âœ… enhanced controllers : updated tools with working messages 2. module control capabilities - direct control : pick, drop, store, check_quality commands work - automatic control : mill/drill commands are handled by aps system - authentication : default / default credentials required 3. tools and scripts created - mqtt_message_library.py : centralized working message library - aps_enhanced_controller.py : enhanced controller using library - module_test_suite.py : comprehensive test suite - updated r">
                        <h3><a href="guides/communication/mqtt/mqtt-control-summary.md">ğŸ¯ MQTT Control Summary - Fischertechnik APS</a></h3>
                        <p>We have successfully **analyzed, tested, and documented** the MQTT control capabilities of the Fischertechnik APS model factory. Through systematic testing, we discovered **working MQTT messages** and...</p>
                        <p><strong>ğŸ“ Pfad:</strong> guides/communication/mqtt/mqtt-control-summary.md</p>
                        <p><strong>ğŸ“Š GrÃ¶ÃŸe:</strong> 7,554 Bytes | <strong>WÃ¶rter:</strong> 941</p>
                        <div class="keywords"></div>
                    </div>

                    <div class="document" data-searchable="ğŸ“¡ nachrichtenzentrale - implementation ğŸ“‹ Ã¼bersicht die nachrichtenzentrale ist ein neuer tab im omf dashboard, der alle mqtt-nachrichten der modellfabrik anzeigt. sie bietet eine Ã¼bersichtliche darstellung von gesendeten und empfangenen nachrichten mit umfassenden filter-optionen. ğŸ—ï¸ architektur âœ… komponenten-struktur: ğŸ“¡ nachrichtenzentrale â”œâ”€â”€ ğŸ¯ omfmqttclient mqtt-client mit singleton-pattern â”œâ”€â”€ ğŸ” filter-system modul, kategorie, zeitraum, topic â”œâ”€â”€ ğŸ“Š nachrichten-tabelle gesendet/empfangen â””â”€â”€ ğŸ”„ auto-refresh konfigurierbar âœ… datei-struktur: src_orbis/omf/dashboard/components/ â”œâ”€â”€ message_center.py haupt-komponente â””â”€â”€ weitere komponenten tests_orbis/ â””â”€â”€ test_message_center.py unit-tests ğŸ¯ funktionalitÃ¤t âœ… 1. nachrichten-anzeige: - zwei tabs: gesendete und empfangene nachrichten - neueste zuerst: chronologische sortierung desc - pagination: automatische begrenzung auf 1000 nachrichten - real-time: live-updates Ã¼ber mqtt âœ… 2. filter-system: python verfÃ¼gbare filter: - ğŸ­ module: hbw, ft">
                        <h3><a href="guides/communication/mqtt/nachrichtenzentrale-implementation.md">ğŸ“¡ Nachrichtenzentrale - Implementation</a></h3>
                        <p>Die **Nachrichtenzentrale** ist ein neuer Tab im OMF Dashboard, der alle MQTT-Nachrichten der Modellfabrik anzeigt. Sie bietet eine Ã¼bersichtliche Darstellung von gesendeten und empfangenen Nachrichte...</p>
                        <p><strong>ğŸ“ Pfad:</strong> guides/communication/mqtt/nachrichtenzentrale-implementation.md</p>
                        <p><strong>ğŸ“Š GrÃ¶ÃŸe:</strong> 6,010 Bytes | <strong>WÃ¶rter:</strong> 591</p>
                        <div class="keywords"></div>
                    </div>

                    <div class="document" data-searchable="remote control guide - fischertechnik aps von macos dieser guide erklÃ¤rt, wie du die fischertechnik aps in der firma von deinem macos-rechner aus steuern kannst. ğŸ¯ Ã¼bersicht setup: macos cursor â†’ remote mqtt client â†’ firmennetzwerk â†’ fischertechnik aps vorteile: - âœ… entwicklung auf macos mit cursor - âœ… direkte steuerung der echten module - âœ… realistische tests mit echter hardware - âœ… keine hardware auf macos nÃ¶tig ğŸ”§ voraussetzungen 1. netzwerkverbindung - beide rechner im gleichen firmennetzwerk - oder vpn-verbindung zur firma - mqtt broker erreichbar port 1883 2. ip-adresse der fischertechnik aps bash in der firma ermitteln: auf dem raspberry pi oder firmenlaptop hostname -i oder ip addr show 3. mqtt broker konfiguration - mqtt broker lÃ¤uft auf der fischertechnik aps - port 1883 ist offen - keine firewall-blockierung ğŸš€ schnellstart 1. ip-adresse ermitteln bash in der firma auf dem fischertechnik system hostname -i beispiel: 192.168.1.100 2. verbindung testen bash von macos aus ping 19">
                        <h3><a href="guides/communication/mqtt/setup/remote-control-guide.md">Remote Control Guide - Fischertechnik APS von macOS</a></h3>
                        <p>Dieser Guide erklÃ¤rt, wie du die Fischertechnik APS in der Firma von deinem macOS-Rechner aus steuern kannst.</p>
                        <p><strong>ğŸ“ Pfad:</strong> guides/communication/mqtt/setup/remote-control-guide.md</p>
                        <p><strong>ğŸ“Š GrÃ¶ÃŸe:</strong> 6,078 Bytes | <strong>WÃ¶rter:</strong> 684</p>
                        <div class="keywords"><span class="keyword">guide</span></div>
                    </div>

                    <div class="document" data-searchable="mqtt traffic logging guide - fischertechnik aps dieser guide erklÃ¤rt, wie du den mqtt-traffic zwischen fischertechnik cloud und lokaler aps Ã¼berwachen und analysieren kannst. ğŸ¯ Ã¼bersicht architektur mit traffic logging: fischertechnik cloud â†â†’ mqtt bridge logger â†â†’ txt 4.0 controller â†â†’ module â†“ traffic logging â†“ log files + database comprehensive monitoring empfohlen : raspberry pi broker 192.168.0.100 â†â†’ comprehensive logger â†â†’ alle nachrichten secondary broker 192.168.2.189 â†â†’ comprehensive logger â†â†’ alle nachrichten docker broker host.docker.internal â†â†’ comprehensive logger â†â†’ alle nachrichten container broker mqtt-broker â†â†’ comprehensive logger â†â†’ alle nachrichten â†“ vollstÃ¤ndige transparenz â†“ log files + database + analysis vorteile: - âœ… vollstÃ¤ndige transparenz Ã¼ber alle mqtt-nachrichten - âœ… non-intrusive - keine Ã¤nderung am bestehenden system - âœ… real-time monitoring mit statistiken - âœ… detaillierte analyse mit visualisierungen - âœ… debugging von kommunikationsproblemen - âœ… alle ">
                        <h3><a href="guides/communication/mqtt/setup/traffic-logging-guide.md">MQTT Traffic Logging Guide - Fischertechnik APS</a></h3>
                        <p>Dieser Guide erklÃ¤rt, wie du den MQTT-Traffic zwischen Fischertechnik Cloud und lokaler APS Ã¼berwachen und analysieren kannst.</p>
                        <p><strong>ğŸ“ Pfad:</strong> guides/communication/mqtt/setup/traffic-logging-guide.md</p>
                        <p><strong>ğŸ“Š GrÃ¶ÃŸe:</strong> 9,860 Bytes | <strong>WÃ¶rter:</strong> 918</p>
                        <div class="keywords"><span class="keyword">guide</span></div>
                    </div>

                    <div class="document" data-searchable="state machine notes fÃ¼r mqtt message templates fts fahrerloses transportsystem - 5io4 zustandsautomat-verhalten findinitialdockposition - verfÃ¼gbarkeit : nur nach initialisierung verfÃ¼gbar - verhalten : wird nach ausfÃ¼hrung deaktiviert - zweck : initiale positionsfindung fÃ¼r fts - fischertechnik-dashboard : button wird nach initialisierung deaktiviert startcharging / stopcharging - verhalten : gegenseitig ausschlieÃŸend - zustandsautomat : - wenn startcharging aktiv â†’ stopcharging verfÃ¼gbar, startcharging deaktiviert - wenn stopcharging aktiv â†’ startcharging verfÃ¼gbar, stopcharging deaktiviert - zweck : verhindert gleichzeitige ladung und ladestopp factsheetrequest - verfÃ¼gbarkeit : immer verfÃ¼gbar - zweck : status-abfrage fÃ¼r dynamische button-aktivierung - zukunft : wird fÃ¼r status-verwaltung verwendet implementierungsnotizen aktueller stand - alle fts-befehle sind immer verfÃ¼gbar einfache implementierung - keine status-verwaltung implementiert geplante erweiterungen - status-verwaltu">
                        <h3><a href="guides/communication/mqtt/state-machine-notes.md">State Machine Notes fÃ¼r MQTT Message Templates</a></h3>
                        <p>- **VerfÃ¼gbarkeit**: Nur nach Initialisierung verfÃ¼gbar</p>
                        <p><strong>ğŸ“ Pfad:</strong> guides/communication/mqtt/state-machine-notes.md</p>
                        <p><strong>ğŸ“Š GrÃ¶ÃŸe:</strong> 3,029 Bytes | <strong>WÃ¶rter:</strong> 339</p>
                        <div class="keywords"></div>
                    </div>

                    <div class="document" data-searchable="ğŸ­ module configuration guide ğŸ“‹ overview die zentrale modul-konfiguration wurde erfolgreich implementiert und ersetzt die veraltete module_mapping.json durch eine moderne yaml-basierte lÃ¶sung mit erweiterten funktionen. âœ… neue features 1. zentrale yaml-konfiguration - datei : src_orbis/mqtt/config/module_config.yml - format : yaml fÃ¼r bessere lesbarkeit und wartung - struktur : hierarchische organisation nach modul-typen 2. modulemanager klasse - datei : src_orbis/mqtt/tools/module_manager.py - funktionen : einheitliche verwaltung fÃ¼r alle tools - backward compatibility : bestehende funktionen bleiben verfÃ¼gbar 3. dashboard integration - neuer tab : "ğŸ­ module" unter "einstellungen" - anzeige : tabellarische darstellung nach modul-typen - ip-ranges : vollstÃ¤ndige ip-adressen-Ã¼bersicht ğŸ­ modul-Ã¼bersicht vollstÃ¤ndige modul-konfiguration: | modul | serial number | typ | ip-range | ip-adressen | befehle | |-------|---------------|-----|----------|-------------|---------| | hbw | svr3qa0022 |">
                        <h3><a href="guides/configuration/module-configuration-guide.md">ğŸ­ Module Configuration Guide</a></h3>
                        <p>Die **zentrale Modul-Konfiguration** wurde erfolgreich implementiert und ersetzt die veraltete `module_mapping.json` durch eine moderne YAML-basierte LÃ¶sung mit erweiterten Funktionen.</p>
                        <p><strong>ğŸ“ Pfad:</strong> guides/configuration/module-configuration-guide.md</p>
                        <p><strong>ğŸ“Š GrÃ¶ÃŸe:</strong> 9,217 Bytes | <strong>WÃ¶rter:</strong> 937</p>
                        <div class="keywords"><span class="keyword">guide</span></div>
                    </div>

                    <div class="document" data-searchable="nfc code configuration guide Ã¼bersicht die nfc-code-konfiguration wurde zentralisiert und verwendet eine yaml-konfigurationsdatei fÃ¼r alle nfc-code-bezogenen operationen im orbis-projekt. ğŸ“ konfigurationsdatei pfad: src_orbis/mqtt/config/nfc_code_config.yml struktur yaml metadata: version: "2.0" description: "nfc code mapping mit erweiterten informationen" last_updated: "2025-08-27" author: "orbis development team" nfc_codes: "040a8dca341291": friendly_id: "r1" color: "red" quality_check: "ok" description: "rotes werkstÃ¼ck 1" ... weitere nfc-codes quality_check_options: - "ok" - "not-ok" - "pending" - "failed" colors: - "red" - "white" - "blue" template_placeholders: nfc_code: "<nfccode>" workpiece_id: "<workpieceid>" color: "<color>" quality: "<quality>" mqtt_paths: - "workpieceid" - "metadata", "workpiece", "workpieceid" - "action", "metadata", "workpiece", "workpieceid" - "workpiece", "workpieceid" - "loadid" - "id" ğŸ”§ nfccodemanager klasse verwendung python from src_orbis.mqtt.tools">
                        <h3><a href="guides/configuration/nfc-code-configuration-guide.md">NFC Code Configuration Guide</a></h3>
                        <p>Die NFC-Code-Konfiguration wurde zentralisiert und verwendet eine YAML-Konfigurationsdatei fÃ¼r alle NFC-Code-bezogenen Operationen im ORBIS-Projekt.</p>
                        <p><strong>ğŸ“ Pfad:</strong> guides/configuration/nfc-code-configuration-guide.md</p>
                        <p><strong>ğŸ“Š GrÃ¶ÃŸe:</strong> 4,433 Bytes | <strong>WÃ¶rter:</strong> 443</p>
                        <div class="keywords"><span class="keyword">guide</span></div>
                    </div>

                    <div class="document" data-searchable="topic-konfiguration guide Ã¼bersicht die topic-konfiguration ist eine zentrale verwaltung aller mqtt-topics fÃ¼r die orbis modellfabrik. sie ersetzt verstreute topic-mappings und bietet eine einheitliche struktur fÃ¼r alle topic-bezogenen informationen. dateien konfigurationsdatei: - pfad : src_orbis/mqtt/config/topic_config.yml - zweck : zentrale yaml-konfiguration aller mqtt-topics manager-klasse: - pfad : src_orbis/mqtt/tools/topic_manager.py - zweck : python-klasse fÃ¼r topic-verwaltung und -abfragen struktur topic-kategorien: 1. ccu central control unit - icon : ğŸ­ - beschreibung : zentrale steuerungseinheit - koordiniert alle module und workflows - topics : 10 topics fÃ¼r status, steuerung und verbindung - sub-kategorien : state, control, status 2. txt txt 4.0 controller - icon : ğŸ›ï¸ - beschreibung : fischertechnik controller fÃ¼r sensorik und aktorik - topics : 17 topics fÃ¼r input/output, sensoren und broadcast - sub-kategorien : function input, function output, control, input, output 3">
                        <h3><a href="guides/configuration/topic-configuration-guide.md">Topic-Konfiguration Guide</a></h3>
                        <p>Die Topic-Konfiguration ist eine zentrale Verwaltung aller MQTT-Topics fÃ¼r die ORBIS Modellfabrik. Sie ersetzt verstreute Topic-Mappings und bietet eine einheitliche Struktur fÃ¼r alle Topic-bezogenen ...</p>
                        <p><strong>ğŸ“ Pfad:</strong> guides/configuration/topic-configuration-guide.md</p>
                        <p><strong>ğŸ“Š GrÃ¶ÃŸe:</strong> 10,091 Bytes | <strong>WÃ¶rter:</strong> 1095</p>
                        <div class="keywords"><span class="keyword">guide</span></div>
                    </div>

                    <div class="document" data-searchable="black/ruff loop problem - pre-commit hooks problem: black/ruff loop bei pre-commit hooks symptom: - pre-commit hooks laufen in einer endlosschleife - black formatiert immer wieder die gleiche datei: src_orbis/omf/config/sequence_definitions/aiqs_sequence.py - ruff zeigt "all checks passed!" aber black formatiert trotzdem aktuelle ausgaben: black output: black....................................................................failed - hook id: black - files were modified by this hook reformatted src_orbis/omf/config/sequence_definitions/aiqs_sequence.py ruff output: ruff.....................................................................passed pytest output: 413 passed, 18 warnings in 23.45s problem-datei: src_orbis/omf/config/sequence_definitions/aiqs_sequence.py aktueller inhalt zeilen 6-8 : python fmt: off from src_orbis.omf.tools.sequence_executor import sequencedefinition, sequencestep fmt: on was passiert: 1. black formatiert die datei und entfernt die fmt: off/on kommentare 2. b">
                        <h3><a href="guides/troubleshooting/BLACK_RUFF_LOOP_PROBLEM.md">Black/Ruff Loop Problem - Pre-commit Hooks</a></h3>
                        <p>- Pre-commit Hooks laufen in einer Endlosschleife</p>
                        <p><strong>ğŸ“ Pfad:</strong> guides/troubleshooting/BLACK_RUFF_LOOP_PROBLEM.md</p>
                        <p><strong>ğŸ“Š GrÃ¶ÃŸe:</strong> 2,282 Bytes | <strong>WÃ¶rter:</strong> 231</p>
                        <div class="keywords"></div>
                    </div>

                    <div class="document" data-searchable="critical bug fix: module-id mapping error ğŸš¨ kritischer bug behoben datum: 2025-01-19 betroffene versionen: dashboardv3.1.0, dashboardv3.1.1 schweregrad: kritisch ğŸ“‹ problem-beschreibung: was passierte: - befehl: drill-pick ausgefÃ¼hrt - tatsÃ¤chlich ausgelÃ¶st: aiqs-pick - ursache: falsche module-id-zuordnung in steering_factory.py betroffene module: - drill bekam fÃ¤lschlicherweise aiqs-seriennummer svr4h76530 - aiqs bekam fÃ¤lschlicherweise mill-seriennummer svr3qa2098 - mill bekam fÃ¤lschlicherweise drill-seriennummer svr4h76449 ğŸ”§ behobene datei: datei: src_orbis/omf/dashboard/components/steering_factory.py funktion: _get_module_serial zeile 198 âŒ vorher falsch : python def _get_module_serial module_name: str -> str: """hilfsfunktion um module-serials zu bekommen""" module_serials = {"aiqs": "svr3qa2098", "mill": "svr4h76449", "drill": "svr4h76530"} return module_serials.get module_name, "unknown" âœ… nachher korrekt : python def _get_module_serial module_name: str -> str: """hilfsfunktion u">
                        <h3><a href="guides/troubleshooting/critical-bug-fix-module-id-mapping.md">Critical Bug Fix: Module-ID Mapping Error</a></h3>
                        <p>**Datum:** 2025-01-19</p>
                        <p><strong>ğŸ“ Pfad:</strong> guides/troubleshooting/critical-bug-fix-module-id-mapping.md</p>
                        <p><strong>ğŸ“Š GrÃ¶ÃŸe:</strong> 3,084 Bytes | <strong>WÃ¶rter:</strong> 318</p>
                        <div class="keywords"></div>
                    </div>

                </div>
            </div>

            <div class="category">
                <h2>ğŸ“‚ helper_apps (1 Dokumente)</h2>
                <div class="documents">

                    <div class="document" data-searchable="ğŸ¬ omf replay station - konzept ğŸ“‹ Ã¼bersicht die omf replay station ist eine separate anwendung, die als lokaler mqtt-broker fungiert und aufgezeichnete session-daten 1:1 wiedergibt. dies ermÃ¶glicht realistische tests ohne echte aps-modellfabrik-verbindung. ğŸ—ï¸ architektur âœ… komponenten-struktur: ğŸ¬ omf replay station â”œâ”€â”€ ğŸ“¡ lokaler mqtt-broker localhost:1884 â”œâ”€â”€ ğŸ® session player â”œâ”€â”€ â±ï¸ replay controller â””â”€â”€ ğŸ“Š session manager ğŸ“Š omf dashboard â”œâ”€â”€ ğŸ”— mqtt-client â†’ localhost:1884 replay-modus â”œâ”€â”€ ğŸ“¡ nachrichtenzentrale â””â”€â”€ ğŸ¯ normale dashboard-funktionen âœ… datenfluss: session-datei .db/.log â†’ session player â†’ lokaler broker â†’ dashboard ğŸ¯ funktionalitÃ¤t âœ… 1. session-player: - session-loading: sqlite-db oder log-dateien laden - message-parsing: nachrichten mit timestamps extrahieren - timing-replay: original-nachrichtenfolgen mit korrektem timing âœ… 2. replay-controller: - play/pause: replay starten/stoppen - speed-control: 0.1x - 5x geschwindigkeit - loop-modus: endlose wiederholung - filter-replay">
                        <h3><a href="helper_apps/omf-replay-station-concept.md">ğŸ¬ OMF Replay Station - Konzept</a></h3>
                        <p>Die **OMF Replay Station** ist eine separate Anwendung, die als lokaler MQTT-Broker fungiert und aufgezeichnete Session-Daten 1:1 wiedergibt. Dies ermÃ¶glicht realistische Tests ohne echte APS-Modellfa...</p>
                        <p><strong>ğŸ“ Pfad:</strong> helper_apps/omf-replay-station-concept.md</p>
                        <p><strong>ğŸ“Š GrÃ¶ÃŸe:</strong> 4,869 Bytes | <strong>WÃ¶rter:</strong> 500</p>
                        <div class="keywords"></div>
                    </div>

                </div>
            </div>

            <div class="category">
                <h2>ğŸ“‚ node-red (3 Dokumente)</h2>
                <div class="documents">

                    <div class="document" data-searchable="node-red documentation this section contains comprehensive documentation for the node-red flows that power the orbis agile production simulation system. ğŸ“‹ documentation index flows overview ./flows-overview.md - tab structure and organization - module-specific flows mill, drill, oven, aiqs, hbw, dps - flow grouping and organization state machine ./state-machine.md - vda 5050 compliant state transitions - action states: pending â†’ running â†’ finished/failed - connection states: online/offline/connectionbroken - error handling and recovery ğŸ”§ quick reference system components - 25 production modules across 5 types - central control unit raspberry pi - mqtt broker 192.168.2.189:1883 - opc-ua network 192.168.0.x:4840 key files - flows.json - main node-red configuration - settings.js - node-red settings - environment variables for configuration access points - node-red ui : http://192.168.0.100:1880/ - ssh access : ff22 / ff22+ - mqtt topics : module/v1/ff/{serialnumber}/{action} ğŸš€ getting sta">
                        <h3><a href="node-red/README.md">Node-RED Documentation</a></h3>
                        <p>This section contains comprehensive documentation for the Node-RED flows that power the Orbis Agile Production Simulation system.</p>
                        <p><strong>ğŸ“ Pfad:</strong> node-red/README.md</p>
                        <p><strong>ğŸ“Š GrÃ¶ÃŸe:</strong> 1,622 Bytes | <strong>WÃ¶rter:</strong> 206</p>
                        <div class="keywords"><span class="keyword">overview</span></div>
                    </div>

                    <div class="document" data-searchable="node-red flows overview this document provides a comprehensive overview of the node-red flows structure in the orbis agile production simulation system. ğŸ“‹ system architecture the node-red system consists of 25 main tabs plus initialization and utility flows, implementing a vda 5050 compliant state machine for industrial automation. flow categories 1. initialization 1 tab 2. production modules 23 tabs 3. central systems 1 tab ğŸ­ production modules mill modules 5 units | module | tab id | opc-ua endpoint | function | |--------|--------|-----------------|----------| | mill 1 | 9810df827082ae56 | 192.168.0.40:4840 | primary milling operations | | mill 2 | f6c8f50b75376b12 | 192.168.0.41:4840 | secondary milling operations | | mill 3 | 05a427a07096ebdb | 192.168.0.42:4840 | tertiary milling operations | | mill 4 | a0e5f985232949c9 | 192.168.0.43:4840 | quaternary milling operations | | mill 5 | 5fc4fbd01fd96575 | 192.168.0.44:4840 | quinary milling operations | key features: - milling operat">
                        <h3><a href="node-red/flows-overview.md">Node-RED Flows Overview</a></h3>
                        <p>This document provides a comprehensive overview of the Node-RED flows structure in the Orbis Agile Production Simulation system.</p>
                        <p><strong>ğŸ“ Pfad:</strong> node-red/flows-overview.md</p>
                        <p><strong>ğŸ“Š GrÃ¶ÃŸe:</strong> 6,186 Bytes | <strong>WÃ¶rter:</strong> 815</p>
                        <div class="keywords"></div>
                    </div>

                    <div class="document" data-searchable="state machine documentation this document describes the vda 5050 compliant state machine implemented in the orbis agile production simulation system. ğŸ”„ state machine overview the system implements a sophisticated state machine that manages the lifecycle of production actions, module connections, and error conditions. this follows the vda 5050 standard for autonomous mobile robots and industrial automation. ğŸ“Š action states primary action states | state | description | color | next states | |-------|-------------|-------|-------------| | pending | action received, waiting to start | ğŸŸ¡ yellow | running, failed | | running | action currently executing | ğŸŸ¡ yellow | finished, failed | | finished | action completed successfully | ğŸŸ¢ green | pending | | failed | action failed with errors | ğŸ”´ red | pending | state transition flow pending â†’ running â†’ finished â†“ â†“ failed â† failed state implementation pending state javascript // action received and validated actionstate.state = "pending"; actionsta">
                        <h3><a href="node-red/state-machine.md">State Machine Documentation</a></h3>
                        <p>This document describes the **VDA 5050 compliant state machine** implemented in the Orbis Agile Production Simulation system.</p>
                        <p><strong>ğŸ“ Pfad:</strong> node-red/state-machine.md</p>
                        <p><strong>ğŸ“Š GrÃ¶ÃŸe:</strong> 8,193 Bytes | <strong>WÃ¶rter:</strong> 986</p>
                        <div class="keywords"></div>
                    </div>

                </div>
            </div>

            <div class="category">
                <h2>ğŸ“‚ releases (6 Dokumente)</h2>
                <div class="documents">

                    <div class="document" data-searchable="release notes verfahren ğŸ“‹ einheitliches format dateiname-konvention: dashboardvx.y.z-release-notes.md beispiele: - dashboardv3.4.0-release-notes.md - dashboardv3.3.1-release-notes.md - dashboardv3.2.0-release-notes.md header-format: markdown omf dashboard vx.y.z - release notes datum: dd. monat yyyy version: x.y.z codename: "kurze beschreibung" status: âœ… released / ğŸš§ in development / ğŸš¨ critical fix ğŸ”„ standardisierte sektionen 1. obligatorische sektionen: - ğŸ¯ Ã¼bersicht - kurze beschreibung der wichtigsten Ã¤nderungen - âœ¨ neue features - neue funktionalitÃ¤ten - ğŸ› bug fixes - behobene probleme - ğŸ§ª testing & quality assurance - tests und qualitÃ¤tssicherung 2. optionale sektionen: - ğŸ”„ verbesserungen - performance, ui/ux verbesserungen - ğŸ“š dokumentation - neue/aktualisierte dokumentation - ğŸš€ deployment - installation und konfiguration - ğŸ¯ nÃ¤chste schritte - geplante features und bekannte issues - ğŸ“Š technische details - architektur, api, dependencies ğŸ“ schreibregeln emojis verwenden: - ğŸ¯ Ã¼bers">
                        <h3><a href="releases/RELEASE_NOTES_PROCEDURE.md">Release Notes Verfahren</a></h3>
                        <p>dashboardvX.Y.Z-release-notes.md</p>
                        <p><strong>ğŸ“ Pfad:</strong> releases/RELEASE_NOTES_PROCEDURE.md</p>
                        <p><strong>ğŸ“Š GrÃ¶ÃŸe:</strong> 3,527 Bytes | <strong>WÃ¶rter:</strong> 400</p>
                        <div class="keywords"><span class="keyword">release</span></div>
                    </div>

                    <div class="document" data-searchable="omf dashboard vx.y.z - release notes datum: dd. monat yyyy version: x.y.z codename: "kurze beschreibung" status: âœ… released / ğŸš§ in development / ğŸš¨ critical fix ğŸ¯ Ã¼bersicht kurze beschreibung der wichtigsten Ã¤nderungen und verbesserungen in dieser version. âœ¨ neue features ğŸ“¦ feature-kategorie 1 - spezifisches feature - beschreibung - weiteres feature - beschreibung ğŸ”§ feature-kategorie 2 - spezifisches feature - beschreibung ğŸ› bug fixes ğŸš¨ critical fixes - problem: beschreibung des problems - lÃ¶sung: beschreibung der lÃ¶sung - betroffen: welche komponenten sind betroffen ğŸ”§ minor fixes - problem: beschreibung - lÃ¶sung: beschreibung ğŸ”„ verbesserungen ğŸš€ performance - verbesserung - beschreibung ğŸ¨ ui/ux - verbesserung - beschreibung ğŸ§ª testing & quality assurance âœ… unit tests - neue tests - beschreibung - test-coverage - prozent ğŸ” integration tests - getestete komponenten - liste ğŸ“š dokumentation ğŸ“– neue dokumentation - dokument - beschreibung ğŸ”„ aktualisierte dokumentation - dokument - was wurde ge">
                        <h3><a href="releases/RELEASE_NOTES_TEMPLATE.md">OMF Dashboard vX.Y.Z - Release Notes</a></h3>
                        <p>**Datum:** DD. Monat YYYY</p>
                        <p><strong>ğŸ“ Pfad:</strong> releases/RELEASE_NOTES_TEMPLATE.md</p>
                        <p><strong>ğŸ“Š GrÃ¶ÃŸe:</strong> 2,165 Bytes | <strong>WÃ¶rter:</strong> 248</p>
                        <div class="keywords"><span class="keyword">release</span></div>
                    </div>

                    <div class="document" data-searchable="omf dashboard v3.1.2 - release notes datum: 19. januar 2025 version: 3.1.2 codename: "critical module-id fix" status: ğŸš¨ critical fix ğŸš¨ critical bug fixes module-id mapping error critical - problem: drill-pick lÃ¶ste fÃ¤lschlicherweise aiqs-pick aus - ursache: falsche seriennummer-zuordnung in _get_module_serial funktion - lÃ¶sung: korrekte module-id-mapping implementiert - betroffene module: - drill: svr4h76449 âœ… war fÃ¤lschlicherweise svr4h76530 - aiqs: svr4h76530 âœ… war fÃ¤lschlicherweise svr3qa2098 - mill: svr3qa2098 âœ… war fÃ¤lschlicherweise svr4h76449 module sequence pick â†’ process â†’ drop - status: âœ… repariert - funktionalitÃ¤t: module-sequenzen funktionieren jetzt korrekt - testing: erfolgreich getestet mit allen modulen ğŸ§ª quality assurance unit tests hinzugefÃ¼gt - neue test-datei: tests_orbis/test_module_id_mapping.py - 9 test-cases fÃ¼r module-id-mapping - kritische bug-prÃ¤vention implementiert - alle tests: âœ… passed test coverage - âœ… module-seriennummer-zuordnung - âœ… eindeutigkeit der s">
                        <h3><a href="releases/dashboardv3.1.2-release-notes.md">OMF Dashboard v3.1.2 - Release Notes</a></h3>
                        <p>**Datum:** 19. Januar 2025</p>
                        <p><strong>ğŸ“ Pfad:</strong> releases/dashboardv3.1.2-release-notes.md</p>
                        <p><strong>ğŸ“Š GrÃ¶ÃŸe:</strong> 3,047 Bytes | <strong>WÃ¶rter:</strong> 334</p>
                        <div class="keywords"><span class="keyword">release</span></div>
                    </div>

                    <div class="document" data-searchable="omf dashboard v3.2.0 - release notes datum: 5. september 2025 version: 3.2.0 codename: "fts & ccu monitoring" status: âœ… released ğŸ¯ Ã¼bersicht dashboard v3.2.0 introduces comprehensive fts and ccu monitoring capabilities with robust template validation, enhanced message processing, and improved user experience. âœ¨ neue features fts fahrerloses transportsystem tab - complete fts monitoring with 5 sub-tabs: - fts_order - fts navigation orders and commands - fts_instantaction - instant actions reset, clearloadhandler, etc. - fts_state - current fts state and position - fts_connection - connection status and health - fts_factsheet - fts configuration and specifications - semantic analysis for all fts mqtt topics - template validation with error tracking - real-time data display with timestamps ccu central control unit tab - complete ccu monitoring with 5 sub-tabs: - ccu_state - ccu system state and inventory - ccu_control - control commands and orders - ccu_set - configuration and reset comma">
                        <h3><a href="releases/dashboardv3.2.0-release-notes.md">OMF Dashboard v3.2.0 - Release Notes</a></h3>
                        <p>**Datum:** 5. September 2025</p>
                        <p><strong>ğŸ“ Pfad:</strong> releases/dashboardv3.2.0-release-notes.md</p>
                        <p><strong>ğŸ“Š GrÃ¶ÃŸe:</strong> 7,190 Bytes | <strong>WÃ¶rter:</strong> 863</p>
                        <div class="keywords"><span class="keyword">release</span></div>
                    </div>

                    <div class="document" data-searchable="omf dashboard v3.3.0 - release notes datum: 4. januar 2025 version: 3.3.0 codename: "dashboard-komponenten-erweiterung" ğŸ¯ Ã¼bersicht diese version erweitert das omf dashboard um neue komponenten fÃ¼r produktkatalog, produktionsplanung und verbessertes shopfloor-layout. alle features sind vollstÃ¤ndig implementiert, getestet und dokumentiert. âœ¨ neue features ğŸ“¦ produktkatalog - yaml-basierte produktdefinitionen fÃ¼r rot, blau, weiss - html-template-system fÃ¼r konsistente visuelle darstellung - produktdetails - material, farbe, grÃ¶ÃŸe aus konfiguration - keine falschen bestand/verfÃ¼gbar-informationen mehr ğŸ“‹ produktionsplanung - fertigungsauftrÃ¤ge aus produktkatalog generieren - vertikale fertigungsablauf-darstellung in schÃ¶nen boxen - hbw als erste box anlieferung , dps als letzte box abgabe - modul-icons fÃ¼r visuelle darstellung der fertigungsschritte - beschreibungen aus yaml-konfiguration ğŸ—ºï¸ shopfloor-layout verbesserungen - 4x3 grid-layout korrekt implementiert - modul-icons werden geladen">
                        <h3><a href="releases/dashboardv3.3.0-release-notes.md">OMF Dashboard v3.3.0 - Release Notes</a></h3>
                        <p>**Datum:** 4. Januar 2025</p>
                        <p><strong>ğŸ“ Pfad:</strong> releases/dashboardv3.3.0-release-notes.md</p>
                        <p><strong>ğŸ“Š GrÃ¶ÃŸe:</strong> 6,956 Bytes | <strong>WÃ¶rter:</strong> 674</p>
                        <div class="keywords"><span class="keyword">release</span></div>
                    </div>

                    <div class="document" data-searchable="dashboard v3.3.1 release notes ğŸ‰ release overview version: 3.3.1 release date: 2025-01-11 status: âœ… completed ğŸš€ major features 1. per-topic-buffer architecture âœ¨ new - topic-spezifische buffer fÃ¼r jede mqtt-subscription - automatische nachrichtensammlung in separaten buffers - effiziente verarbeitung ohne message-processor overhead - direkte buffer-zugriffe fÃ¼r optimale performance 2. mqtt-singleton pattern âœ¨ new - eine mqtt-client-instanz pro streamlit-session - zentraler zugriff Ã¼ber st.session_state "mqtt_client" - stabile verbindungen ohne verletzung des singleton-patterns - umgebungswechsel live/mock/replay ohne probleme 3. hybrid-architektur fÃ¼r publishing âœ¨ new - messagegenerator fÃ¼r payload-erstellung - session state fÃ¼r preview/edit-funktionalitÃ¤t - mqttgateway fÃ¼r finales publishing - workflowordermanager fÃ¼r orderid/orderupdateid verwaltung ğŸ”§ technical improvements architecture migration - von message-processor zu per-topic-buffer: komplette architektur-migration - mqtt-sing">
                        <h3><a href="releases/dashboardv3.3.1-release-notes.md">Dashboard v3.3.1 Release Notes</a></h3>
                        <p>**Version:** 3.3.1</p>
                        <p><strong>ğŸ“ Pfad:</strong> releases/dashboardv3.3.1-release-notes.md</p>
                        <p><strong>ğŸ“Š GrÃ¶ÃŸe:</strong> 10,827 Bytes | <strong>WÃ¶rter:</strong> 1029</p>
                        <div class="keywords"><span class="keyword">release</span></div>
                    </div>

                </div>
            </div>

            <div class="category">
                <h2>ğŸ“‚ root (15 Dokumente)</h2>
                <div class="documents">

                    <div class="document" data-searchable="changelog alle wichtigen Ã¤nderungen an diesem projekt werden in dieser datei dokumentiert. das format basiert auf keep a changelog https://keepachangelog.com/de/1.0.0/ , und dieses projekt folgt semantic versioning https://semver.org/spec/v2.0.0.html . unreleased geplant - messagegenerator integration - replay station fÃ¼r dashboard-tests - template-analyse erweitern 3.3.1 - 2025-01-xx hinzugefÃ¼gt - session manager: session analyse - timeline-visualisierung mit plotly - topic-filterung kategorie, sub-kategorie, friendly name, topic name - vorfilter-system fÃ¼r uninteressante topics - zeitfilter fÃ¼r timeline-analyse - settings-management fÃ¼r vorfilter-konfiguration - payload-analyse und message-details geÃ¤ndert - projekt-struktur aufgerÃ¤umt - dokumentation konsolidiert - import-standards vereinheitlicht behoben - importerror fÃ¼r omftopicmanager - vorfilter-loop-problem - struktur-validierung implementiert 3.3.0 - 2025-01-xx hinzugefÃ¼gt - per-topic-buffer architektur - mqtt-singleton patte">
                        <h3><a href="CHANGELOG.md">Changelog</a></h3>
                        <p>Alle wichtigen Ã„nderungen an diesem Projekt werden in dieser Datei dokumentiert.</p>
                        <p><strong>ğŸ“ Pfad:</strong> CHANGELOG.md</p>
                        <p><strong>ğŸ“Š GrÃ¶ÃŸe:</strong> 2,638 Bytes | <strong>WÃ¶rter:</strong> 278</p>
                        <div class="keywords"></div>
                    </div>

                    <div class="document" data-searchable="omf modellfabrik - entwicklungsregeln > ğŸ“ position: docs_orbis/development_rules.md > ğŸ¤– cursor ai: siehe .cursorrules fÃ¼r ki-spezifische regeln ğŸ¯ grundprinzipien 1. einfaches grundgerÃ¼st - keine Ã¼berladung mit nicht notwendiger funktionalitÃ¤t - minimaler code fÃ¼r maximale Ã¼bersichtlichkeit - schritt-fÃ¼r-schritt entwicklung - tests nach jeder Ã¤nderung 2. sichere vorgehensweise - dashboard_migration_plan befolgen - hÃ¤ufige commits nach jedem erfolgreichen schritt - rollback bei fehlern mÃ¶glich - immer funktionierenden stand haben 3. saubere architektur - trennung: aktive sourcen vs. helper-apps - aktive sourcen: src_orbis/omf/dashboard/ produktiv-dashboard - helper-apps: src_orbis/helper_apps/ , src_orbis/analysis_tools/ separate anwendungen - modulare komponenten in separaten dateien - klare import-pfade und abhÃ¤ngigkeiten - zweisprachigkeit: source-namen en, ui-namen de 4. import-standards zentrale entwicklungsregel - nur absolute imports verwenden: from src_orbis.omf.module import cla">
                        <h3><a href="DEVELOPMENT_RULES.md">**OMF Modellfabrik - Entwicklungsregeln**</a></h3>
                        <p>> **ğŸ“ Position:** `docs_orbis/DEVELOPMENT_RULES.md`</p>
                        <p><strong>ğŸ“ Pfad:</strong> DEVELOPMENT_RULES.md</p>
                        <p><strong>ğŸ“Š GrÃ¶ÃŸe:</strong> 9,075 Bytes | <strong>WÃ¶rter:</strong> 903</p>
                        <div class="keywords"></div>
                    </div>

                    <div class="document" data-searchable="ğŸ“‹ import-standards guide - omf projekt ğŸ¯ zentrale entwicklungsregel nur absolute imports verwenden - keine ausnahmen! âœ… korrekte imports dashboard-komponenten: python âœ… korrekt from src_orbis.omf.dashboard.components.dummy_component import show_dummy from src_orbis.omf.dashboard.assets.html_templates import get_template from src_orbis.omf.dashboard.omf_dashboard import main tools und utilities: python âœ… korrekt from src_orbis.omf.tools.sequence_executor import sequenceexecutor from src_orbis.omf.tools.sequence_ui import sequenceui from src_orbis.omf.tools.message_template_manager import get_message_template_manager from src_orbis.omf.tools.topic_manager import get_omf_topic_manager konfiguration: python âœ… korrekt from src_orbis.omf.config.config import config from src_orbis.omf.config.omf_config import config from src_orbis.omf.config.sequence_definitions.aiqs_sequence import aiqssequence helper-apps: python âœ… korrekt from src_orbis.helper_apps.replay_station.replay_station_dashboard i">
                        <h3><a href="IMPORT_STANDARDS_GUIDE.md">ğŸ“‹ Import-Standards Guide - OMF Projekt</a></h3>
                        <p>**NUR absolute Imports verwenden - KEINE Ausnahmen!**</p>
                        <p><strong>ğŸ“ Pfad:</strong> IMPORT_STANDARDS_GUIDE.md</p>
                        <p><strong>ğŸ“Š GrÃ¶ÃŸe:</strong> 5,903 Bytes | <strong>WÃ¶rter:</strong> 553</p>
                        <div class="keywords"><span class="keyword">guide</span></div>
                    </div>

                    <div class="document" data-searchable="omf orbis modellfabrik dashboard architecture overview das omf dashboard ist eine moderne, modulare web-anwendung zur steuerung und Ã¼berwachung der orbis modellfabrik. es basiert auf streamlit und implementiert die per-topic-buffer architektur mit mqtt-singleton pattern fÃ¼r optimale performance und einfachheit. architecture overview omf dashboard â”œâ”€â”€ frontend streamlit â”‚ â”œâ”€â”€ main dashboard omf_dashboard.py â”‚ â””â”€â”€ components â”‚ â”œâ”€â”€ overview components â”‚ â”‚ â”œâ”€â”€ overview_inventory.py lagerbestand â”‚ â”‚ â”œâ”€â”€ overview_customer_order.py kundenauftrÃ¤ge â”‚ â”‚ â”œâ”€â”€ overview_purchase_order.py rohmaterial-bestellungen â”‚ â”‚ â””â”€â”€ overview_module_status.py modul-status per-topic-buffer â”‚ â”œâ”€â”€ production order components â”‚ â”‚ â”œâ”€â”€ production_order_management.py auftragsverwaltung â”‚ â”‚ â””â”€â”€ production_order_current.py laufende auftrÃ¤ge â”‚ â”œâ”€â”€ steering components â”‚ â”‚ â”œâ”€â”€ steering_factory.py factory-steuerung hybrid-architektur â”‚ â”‚ â”œâ”€â”€ steering_sequence.py sequenz-steuerung â”‚ â”‚ â””â”€â”€ steering_generic.py generic-steuerung ">
                        <h3><a href="OMF_ARCHITECTURE.md">OMF (ORBIS Modellfabrik) Dashboard Architecture</a></h3>
                        <p>Das OMF Dashboard ist eine moderne, modulare Web-Anwendung zur Steuerung und Ãœberwachung der ORBIS Modellfabrik. Es basiert auf Streamlit und implementiert die **Per-Topic-Buffer Architektur** mit **M...</p>
                        <p><strong>ğŸ“ Pfad:</strong> OMF_ARCHITECTURE.md</p>
                        <p><strong>ğŸ“Š GrÃ¶ÃŸe:</strong> 19,119 Bytes | <strong>WÃ¶rter:</strong> 1738</p>
                        <div class="keywords"></div>
                    </div>

                    <div class="document" data-searchable="orbis modellfabrik - projekt-Ã¼bersicht ğŸ¯ projektziel verstÃ¤ndnis der funktionsweise der aps fischertechnik anwendung, um eine eigene anwendung zu bauen, die die steuerung der modellfabrik Ã¼bernimmt. aps-fischertechnik system - reale miniatur-fabrik mit verschiedenen modulen - software zur steuerung der fabrik-prozesse - hauptprozesse: - wareneingang - produktion nach bestellung ğŸš€ geplante vorgehensweise phase 1: nachrichten-fluÃŸ aufnehmen âœ… - session-rekording der komponenten und module der aps-fabrik - status: abgeschlossen Ã¼ber python-script phase 2: session-analyse ğŸ”„ - aktueller fokus: semantik und funktionsweise analysieren - ziel: erkenntnisse sammeln fÃ¼r steuerungs-entwicklung - tools: session manager helper app phase 3: steuerungs-entwicklung ğŸ“‹ - ziel: anwendung fÃ¼r befehle/messages an fabrik-komponenten - tool: omf dashboard - funktion: senden von messages fÃ¼r aufgaben-erfÃ¼llung ğŸ—ï¸ teilprojekte session manager helper app zweck: analyse und test der aufgenommenen sessions kompon">
                        <h3><a href="PROJECT_OVERVIEW.md">ORBIS Modellfabrik - Projekt-Ãœbersicht</a></h3>
                        <p>VerstÃ¤ndnis der Funktionsweise der APS Fischertechnik Anwendung, um eine eigene Anwendung zu bauen, die die Steuerung der Modellfabrik Ã¼bernimmt.</p>
                        <p><strong>ğŸ“ Pfad:</strong> PROJECT_OVERVIEW.md</p>
                        <p><strong>ğŸ“Š GrÃ¶ÃŸe:</strong> 3,380 Bytes | <strong>WÃ¶rter:</strong> 360</p>
                        <div class="keywords"></div>
                    </div>

                    <div class="document" data-searchable="orbis modellfabrik - documentation this directory contains comprehensive documentation for the orbis modellfabrik system, based on the fischertechnik agile production simulation 24v. ğŸ“ folder structure original fischertechnik content - data/ - original data files - plc-programs/ - original plc programs - txt4.0-programs/ - original txt4.0 programs - node-red/ - original node-red flows - doc/ - original documentation orbis customizations - docs_orbis/ - orbis documentation this folder - src_orbis/ - orbis source code - tests_orbis/ - orbis tests ğŸ“š documentation structure project overview ./project_overview.md - system overview - complete project analysis and architecture - core technology - mqtt-based communication system - orbis components - central configuration managers and dashboard - current status - modern yaml-based architecture development rules ./development_rules.md - import standards - absolute imports only - code quality - black, ruff, pre-commit hooks - test standards - bra">
                        <h3><a href="README.md">Orbis Modellfabrik - Documentation</a></h3>
                        <p>This directory contains comprehensive documentation for the Orbis Modellfabrik system, based on the Fischertechnik Agile Production Simulation 24V.</p>
                        <p><strong>ğŸ“ Pfad:</strong> README.md</p>
                        <p><strong>ğŸ“Š GrÃ¶ÃŸe:</strong> 6,604 Bytes | <strong>WÃ¶rter:</strong> 799</p>
                        <div class="keywords"><span class="keyword">overview</span></div>
                    </div>

                    <div class="document" data-searchable="ğŸ” orbis modellfabrik - credentials & access this document contains default login credentials and access information for the orbis modellfabrik system components. âš ï¸ security notice important : these are default credentials. for production use, always change default passwords and use secure authentication methods. ğŸ­ aps modellfabrik components ccu central control unit - raspberry pi - komponente : ccu central control unit - hardware : raspberry pi - ip address : 192.168.0.100 - web interface : http://192.168.0.100/de/aps/ - ssh access : - username: ff22 - default password: ff22+ - ssh port: 22 - status : âœ… web-interface funktioniert! - ssh zu testen - beschreibung : zentrale steuereinheit der aps-modellfabrik mqtt broker mosquitto - komponente : mqtt broker - software : mosquitto - host : 192.168.0.100 - port : 1883 - authentication : required currently blocking connections - default login : default / default - status : âœ… funktioniert! - verbindung erfolgreich - beschreibung : mqtt-brok">
                        <h3><a href="credentials.md">ğŸ” Orbis Modellfabrik - Credentials & Access</a></h3>
                        <p>This document contains default login credentials and access information for the Orbis Modellfabrik system components.</p>
                        <p><strong>ğŸ“ Pfad:</strong> credentials.md</p>
                        <p><strong>ğŸ“Š GrÃ¶ÃŸe:</strong> 6,823 Bytes | <strong>WÃ¶rter:</strong> 915</p>
                        <div class="keywords"></div>
                    </div>

                    <div class="document" data-searchable="factory steering regeln Ã¼bersicht dieses dokument beschreibt die aktuellen regeln fÃ¼r die factory_steering.py komponente im omf dashboard. diese regeln stellen sicher, dass alle mqtt-nachrichten den korrekten standards entsprechen. wichtige prinzipien 1. historische tests bleiben unverÃ¤ndert - unit-tests aus commit 807c29a sind historische referenzen - sie dokumentieren, was in diesem commit funktioniert hat - sie werden nicht angepasst oder geÃ¤ndert 2. neue tests fÃ¼r aktuelle regeln - neue unit-tests validieren die aktuellen implementierungen - sie testen topic + message + regeln in kombination - sie stellen sicher, dass die regeln eingehalten werden mqtt topic regeln modul-topics alle modul-befehle verwenden das folgende topic-pattern: module/v1/ff/{serial_number}/order spezifische topics: - drill : module/v1/ff/svr4h76449/order - mill : module/v1/ff/svr3qa2098/order - aiqs : module/v1/ff/svr4h76530/order fts-topics fts-befehle verwenden: fts/v1/ff/5io4/order ccu-topics factory-reset">
                        <h3><a href="factory_steering_rules.md">Factory Steering Regeln</a></h3>
                        <p>Dieses Dokument beschreibt die aktuellen Regeln fÃ¼r die `factory_steering.py` Komponente im OMF Dashboard. Diese Regeln stellen sicher, dass alle MQTT-Nachrichten den korrekten Standards entsprechen.</p>
                        <p><strong>ğŸ“ Pfad:</strong> factory_steering_rules.md</p>
                        <p><strong>ğŸ“Š GrÃ¶ÃŸe:</strong> 5,415 Bytes | <strong>WÃ¶rter:</strong> 590</p>
                        <div class="keywords"></div>
                    </div>

                    <div class="document" data-searchable="fts navigation examples ğŸ—ºï¸ fts grid-layout 4x3 raster : empty mill aiqs empty | | hbw ------ 1 ------- 2 ------- dps | | drill ----- 3 ------- 4 ------- chrg0 ğŸ“Š grid-details: module-positionen 6 : - hbw: links unten - drill: links unten zweite reihe - mill: oben mitte - aiqs: oben rechts - dps: rechts mitte - chrg0: rechts unten kreuzungspunkte/intersections 4 : - 1: mitte links hbw â†” mill - 2: mitte rechts mill â†” aiqs â†” dps - 3: unten links drill â†” hbw - 4: unten rechts drill â†” chrg0 â†” dps ğŸ¯ navigation-logik: - navigation: position â†’ position - kreuzungspunkte: links, rechts, pass-through je nach ziel - grid-basierte navigation mit 10 positionen 6 module + 4 intersections ğŸš› funktionierende fts-navigation: dps â†’ hbw topic: fts/v1/ff/5io4/order payload: json { "timestamp": "2025-01-19t10:00:00.000z", "orderid": "test-navigation-dps-to-hbw-wareneingang-001", "orderupdateid": 0, "nodes": { "id": "svr4h73275", "linkededges": "svr4h73275-2" }, { "id": "2", "linkededges": "svr4h73275-2", "2-">
                        <h3><a href="fts-navigation-examples.md">fts-navigation-examples</a></h3>
                        <p>[EMPTY]    [MILL]    [AIQS]    [EMPTY]</p>
                        <p><strong>ğŸ“ Pfad:</strong> fts-navigation-examples.md</p>
                        <p><strong>ğŸ“Š GrÃ¶ÃŸe:</strong> 8,510 Bytes | <strong>WÃ¶rter:</strong> 888</p>
                        <div class="keywords"></div>
                    </div>

                    <div class="document" data-searchable="per-topic-buffer pattern Ã¼bersicht das per-topic-buffer pattern ist die aktuelle architektur fÃ¼r mqtt-nachrichtenverarbeitung im omf dashboard. es bietet eine saubere, effiziente lÃ¶sung fÃ¼r die verarbeitung von mqtt-nachrichten. architektur-prinzipien 1. mqtt-singleton pattern - eine mqtt-client-instanz pro streamlit-session - zentraler zugriff Ã¼ber st.session_state "mqtt_client" - keine verletzung des singleton-patterns durch direkte client-aufrufe 2. per-topic-buffer system - topic-spezifische buffer fÃ¼r jede mqtt-subscription - automatische nachrichtensammlung in separaten buffers - effiziente verarbeitung ohne message-processor overhead 3. hybrid-architektur fÃ¼r publishing - messagegenerator fÃ¼r payload-erstellung - session state fÃ¼r preview/edit-funktionalitÃ¤t - mqttgateway fÃ¼r finales publishing implementierung subscription pattern python 1. topics subscriben client.subscribe_many "module/v1/ff/+/state", "module/v1/ff/+/connection", "ccu/pairing/state", "module/v1/ff/+/factsheet"">
                        <h3><a href="per-topic-buffer-pattern.md">Per-Topic-Buffer Pattern</a></h3>
                        <p>Das **Per-Topic-Buffer Pattern** ist die aktuelle Architektur fÃ¼r MQTT-Nachrichtenverarbeitung im OMF Dashboard. Es bietet eine saubere, effiziente LÃ¶sung fÃ¼r die Verarbeitung von MQTT-Nachrichten.</p>
                        <p><strong>ğŸ“ Pfad:</strong> per-topic-buffer-pattern.md</p>
                        <p><strong>ğŸ“Š GrÃ¶ÃŸe:</strong> 6,110 Bytes | <strong>WÃ¶rter:</strong> 540</p>
                        <div class="keywords"></div>
                    </div>

                    <div class="document" data-searchable="voraussetzungen fÃ¼r mqtt mock system dieser guide listet alle notwendigen voraussetzungen fÃ¼r das testen des mqtt mocking systems auf. ğŸ”§ systemvoraussetzungen 1. python version 3.7 oder hÃ¶her prÃ¼fung: bash python3 --version installation falls nicht vorhanden : bash macos brew install python3 ubuntu/debian sudo apt update sudo apt install python3 python3-pip windows download von python.org 2. mqtt broker mosquitto installation: bash macos brew install mosquitto ubuntu/debian sudo apt install mosquitto mosquitto-clients windows download von mosquitto.org alternative: docker bash docker run -d --name mqtt-broker \ -p 1883:1883 \ -p 9001:9001 \ eclipse-mosquitto:latest 3. python dependencies automatische installation: bash alle dependencies installieren pip install -r requirements.txt oder nur mqtt pip install paho-mqtt>=1.6.1 manuelle installation: bash pip install paho-mqtt pip install numpy pip install pandas pip install matplotlib pip install seaborn ğŸš€ schnelltest der voraussetzungen a">
                        <h3><a href="prerequisites.md">Voraussetzungen fÃ¼r MQTT Mock System</a></h3>
                        <p>Dieser Guide listet alle notwendigen Voraussetzungen fÃ¼r das Testen des MQTT Mocking Systems auf.</p>
                        <p><strong>ğŸ“ Pfad:</strong> prerequisites.md</p>
                        <p><strong>ğŸ“Š GrÃ¶ÃŸe:</strong> 4,484 Bytes | <strong>WÃ¶rter:</strong> 538</p>
                        <div class="keywords"></div>
                    </div>

                    <div class="document" data-searchable="omf streamlit dashboard anforderungen 1 ziel und nutzen - nachbau der applikation aps von fischertechnuk - echtzeit-monitoring aller module und deren status - nachrichtenverwaltung mit persistierung und historie - steuerung der fabrik-module, komponenten und prozesse durch versenden von mqtt-messages, so wie es die aps applikation macht. - messagetemplate syntaktische und semantische beschreibung der nachrichten der aps, sowie kopplung zu den mqtt-topics, damit eine steuerung mÃ¶glich ist. - replay-station abspielen von zuvor aufgenommenn sessions nachrichten-auustausch zu testzwecken, dazu kann das dashboard wahlweise die verbindung zu aps-mqtt-broker oder zu einem lokalen broker aufgebaut werden, der Ã¼ber ein separates dashboard, die aufgenommenen nachrichten abspielen=senden kann. 2 architektur kurz - omfmqttclient als zentraler mqtt-client singleton-pattern - @st.cache_resource fÃ¼r persistente services Ã¼ber streamlit-reruns - einzelner mqtt-client fÃ¼r subscribe und publish - thread-">
                        <h3><a href="requirements_dashboard.md">OMF Streamlit Dashboard Anforderungen</a></h3>
                        <p>- **Nachbau der Applikation APS von Fischertechnuk**</p>
                        <p><strong>ğŸ“ Pfad:</strong> requirements_dashboard.md</p>
                        <p><strong>ğŸ“Š GrÃ¶ÃŸe:</strong> 15,476 Bytes | <strong>WÃ¶rter:</strong> 1750</p>
                        <div class="keywords"></div>
                    </div>

                    <div class="document" data-searchable="anforderungen: sequenzielle steuerungsbefehle in logischer klammer mit ui-unterstÃ¼tzung finale version problemstellung die orbis modellfabrik benÃ¶tigt ein system zur sequenziellen ausfÃ¼hrung von steuerungsbefehlen mit ui-unterstÃ¼tzung in logischer klammer . aktuell werden module mill, drill, aiqs manuell schritt-fÃ¼r-schritt gesteuert, was fehleranfÃ¤llig und zeitaufwendig ist. die steuerungsbefehle werden in form von mqtt-messages an die module abgesendet. --- funktionale anforderungen 1. logische klammer fÃ¼r sequenz-ausfÃ¼hrung - geschlossene einheit : eine sequenz lÃ¤uft als logische einheit z.b. pick â†’ process â†’ drop - abbruch-fÃ¤higkeit : bei bedarf kann die sequenz abgebrochen werden - konsistente ids : orderid bleibt konstant, orderupdateid wird pro schritt inkrementiert - status-tracking : vollstÃ¤ndige nachverfolgung des sequenz-status 2. ui-unterstÃ¼tzung fÃ¼r sequenzen - sequenz-fenster : Ã¶ffnet sich bei sequenz-start und bleibt bis ende offen - visuelle sequenz-darstellung : schrit">
                        <h3><a href="requirements_sequence_control.md">**Anforderungen: Sequenzielle Steuerungsbefehle in logischer Klammer mit UI-UnterstÃ¼tzung (Finale Version)**</a></h3>
                        <p>Die ORBIS Modellfabrik benÃ¶tigt ein System zur **sequenziellen AusfÃ¼hrung von Steuerungsbefehlen** mit **UI-UnterstÃ¼tzung in logischer Klammer**. Aktuell werden Module (MILL, DRILL, AIQS) manuell Schr...</p>
                        <p><strong>ğŸ“ Pfad:</strong> requirements_sequence_control.md</p>
                        <p><strong>ğŸ“Š GrÃ¶ÃŸe:</strong> 7,695 Bytes | <strong>WÃ¶rter:</strong> 874</p>
                        <div class="keywords"></div>
                    </div>

                    <div class="document" data-searchable="sequenz-steuerung implementation - januar 2025 ğŸ¯ Ã¼bersicht die sequenz-steuerung wurde erfolgreich implementiert und in das omf dashboard integriert. sie ermÃ¶glicht die automatisierte ausfÃ¼hrung von vordefinierten sequenzen mit korrekten mqtt-nachrichten, die identisch mit der factory-steuerung sind. âœ… implementierte features 1. sequenz-definitionen - drill-sequenz: pick â†’ drill â†’ drop - mill-sequenz: pick â†’ mill â†’ drop - aiqs-sequenz: pick â†’ check_quality â†’ drop 2. automatische sequenz-ausfÃ¼hrung - automatische progression: nÃ¤chste schritte werden automatisch nach 5 sekunden ausgefÃ¼hrt - wait-steps: konfigurierbare wartezeiten zwischen schritten standard: 5 sekunden - status-tracking: detaillierte verfolgung des sequenz-fortschritts 3. mqtt-integration - identische nachrichten-struktur: sequenz-nachrichten sind identisch mit factory-steuerung - korrekte payload-formatierung: json { "serialnumber": "svr4h76530", "action": { "id": "uuid-here", "command": "pick", "metadata": { "priority"">
                        <h3><a href="sequence-control-implementation-2025-01.md">Sequenz-Steuerung Implementation - Januar 2025</a></h3>
                        <p>Die Sequenz-Steuerung wurde erfolgreich implementiert und in das OMF Dashboard integriert. Sie ermÃ¶glicht die automatisierte AusfÃ¼hrung von vordefinierten Sequenzen mit korrekten MQTT-Nachrichten, die...</p>
                        <p><strong>ğŸ“ Pfad:</strong> sequence-control-implementation-2025-01.md</p>
                        <p><strong>ğŸ“Š GrÃ¶ÃŸe:</strong> 5,664 Bytes | <strong>WÃ¶rter:</strong> 544</p>
                        <div class="keywords"></div>
                    </div>

                    <div class="document" data-searchable="singleton-pattern compliance âœ… aktuell korrekt umgesetzt 1. einziger client pro session - implementiert: ensure_dashboard_client in omf_dashboard.py - speicherung: st.session_state "mqtt_client" - dokumentation: "liefert genau einen mqtt-client pro streamlit-session" 2. idempotente subscriptions - implementiert: subscribe_many verhindert doppelte subscriptions - code: new_ones = f for f in filters if f not in self._subscribed 3. komponenten-parameter-pattern - implementiert: mqttgateway wird an komponenten Ã¼bergeben - keine direkten client-erstellungen in komponenten 4. umgebungswechsel - implementiert: reconnect statt neuer client-instanz - fallback: nur bei fehlern wird neuer client erstellt âš ï¸ noch zu implementieren 1. message callback idempotenz problem: doppelte callbacks mÃ¶glich python aktuell: for f in new_ones: self.client.subscribe f, qos=qos self._subscribed.add f empfohlen: for f in new_ones: self.client.subscribe f, qos=qos self.client.message_callback_add f, self._dispatch">
                        <h3><a href="singleton-pattern-compliance.md">Singleton-Pattern Compliance</a></h3>
                        <p>- **Implementiert:** `ensure_dashboard_client()` in `omf_dashboard.py`</p>
                        <p><strong>ğŸ“ Pfad:</strong> singleton-pattern-compliance.md</p>
                        <p><strong>ğŸ“Š GrÃ¶ÃŸe:</strong> 3,235 Bytes | <strong>WÃ¶rter:</strong> 359</p>
                        <div class="keywords"></div>
                    </div>

                </div>
            </div>

        </div>
    </div>
    
    <script>
        function searchDocuments() {
            const searchTerm = document.getElementById('searchInput').value.toLowerCase();
            const documents = document.querySelectorAll('.document');
            
            documents.forEach(doc => {
                const searchableContent = doc.getAttribute('data-searchable');
                if (searchableContent.includes(searchTerm) || searchTerm === '') {
                    doc.style.display = 'block';
                } else {
                    doc.style.display = 'none';
                }
            });
        }
    </script>
</body>
</html>
