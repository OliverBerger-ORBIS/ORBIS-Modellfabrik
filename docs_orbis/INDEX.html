<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ORBIS-Modellfabrik - Dokumentationsindex</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; margin: 0; padding: 20px; background: #f5f5f5; }
        .container { max-width: 1200px; margin: 0 auto; background: white; padding: 30px; border-radius: 10px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
        h1 { color: #2c3e50; border-bottom: 3px solid #3498db; padding-bottom: 10px; }
        .search-box { margin: 20px 0; padding: 15px; background: #ecf0f1; border-radius: 5px; }
        .search-box input { width: 100%; padding: 10px; border: 1px solid #bdc3c7; border-radius: 5px; font-size: 16px; }
        .category { margin: 30px 0; }
        .category h2 { color: #34495e; background: #ecf0f1; padding: 10px; border-radius: 5px; }
        .documents { display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 15px; margin-top: 15px; }
        .document { background: #f8f9fa; padding: 15px; border-radius: 5px; border-left: 4px solid #3498db; }
        .document h3 { margin: 0 0 10px 0; color: #2c3e50; }
        .document p { margin: 5px 0; color: #7f8c8d; font-size: 14px; }
        .document a { color: #3498db; text-decoration: none; }
        .document a:hover { text-decoration: underline; }
        .keywords { margin-top: 10px; }
        .keyword { display: inline-block; background: #e74c3c; color: white; padding: 2px 8px; border-radius: 12px; font-size: 12px; margin: 2px; }
        .stats { background: #2ecc71; color: white; padding: 15px; border-radius: 5px; margin-bottom: 20px; }
    </style>
</head>
<body>
    <div class="container">
        <h1>📚 ORBIS-Modellfabrik - Dokumentationsindex</h1>
        
        <div class="stats">
            <strong>📊 Statistiken:</strong>
            50 Dokumente in 7 Kategorien
            | Generiert am 12.09.2025 12:10
        </div>
        
        <div class="search-box">
            <input type="text" id="searchInput" placeholder="🔍 Dokumentation durchsuchen..." onkeyup="searchDocuments()">
        </div>
        
        <div id="categories">

            <div class="category">
                <h2>📂 analysis (8 Dokumente)</h2>
                <div class="documents">

                    <div class="document" data-searchable="umfassende workflow-analyse: wareneingang, auftrag und ai-not-ok sessions 📋 übersicht diese umfassende analyse untersucht alle workflow-typen der aps-modellfabrik: - wareneingang rot, weiss, blau - werkstück-eingang und lagerung - auftrag rot, weiss, blau - produktionsaufträge mit verarbeitung - ai-not-ok rot, weiss, blau - produktionsaufträge mit ai-prüfung ziel: vollständiges verständnis der workflows für template message entwicklung. 🎯 analysierte sessions wareneingang sessions 9 - aps_persistent_traffic_wareneingang-rot_1.db bis wareneingang-rot_3.db - aps_persistent_traffic_wareneingang-weiss_1.db bis wareneingang-weiss_3.db - aps_persistent_traffic_wareneingang-blau_1.db bis wareneingang-blau_3.db auftrag sessions 3 - aps_persistent_traffic_auftrag-rot_1.db - aps_persistent_traffic_auftrag-weiss_1.db - aps_persistent_traffic_auftrag-blau_1.db ai-not-ok sessions 3 - aps_persistent_traffic_ai-not-ok-rot_1.db - aps_persistent_traffic_ai-not-ok-weiss_1.db - aps_persistent_traffic_ai-">
                        <h3><a href="analysis/comprehensive-workflow-analysis.md">Umfassende Workflow-Analyse: Wareneingang, Auftrag und AI-not-ok Sessions</a></h3>
                        <p>Diese umfassende Analyse untersucht alle Workflow-Typen der APS-Modellfabrik:</p>
                        <p><strong>📁 Pfad:</strong> analysis/comprehensive-workflow-analysis.md</p>
                        <p><strong>📊 Größe:</strong> 12,206 Bytes | <strong>Wörter:</strong> 1400</p>
                        <div class="keywords"></div>
                    </div>

                    <div class="document" data-searchable="📝 dokumentation update summary - commit 19.08.2025 🗑️ gelöschte dateien - docs_orbis/copilot_push_test.md - test-datei, nicht relevant - docs_orbis/push_test.md - test-datei, nicht relevant - docs_orbis/chat.txt - temporäre chat-datei 📝 aktualisierte dokumentation 1. docs_orbis/mqtt/mqtt-control-summary.md änderungen: - ✅ neue befehle hinzugefügt : mill mill , drill drill , dps input_rgb, rgb_nfc - 🚨 kritisches problem : order-id management als priorität markiert - 📋 next steps : order-id management als kritische phase 1 definiert - 🔍 important findings : orderupdateid inkrementierung dokumentiert 2. docs_orbis/analysis/mqtt-template-testing-strategie.md änderungen: - 🎯 strategie geändert : von "hybrid-ansatz" zu "order-id fokus" - 🚨 phase 1 : order-id management als kritische priorität - 📊 testing-plan : workflowordermanager als erste phase - 📝 fazit : order-id management als essentiell markiert 3. docs_orbis/analysis/mqtt-template-testing-ergebnisse.md änderungen: - 📊 neue templates ">
                        <h3><a href="analysis/documentation-update-summary.md">📝 Dokumentation Update Summary - Commit 19.08.2025</a></h3>
                        <p>- `docs_orbis/copilot_push_test.md` - Test-Datei, nicht relevant</p>
                        <p><strong>📁 Pfad:</strong> analysis/documentation-update-summary.md</p>
                        <p><strong>📊 Größe:</strong> 2,828 Bytes | <strong>Wörter:</strong> 313</p>
                        <div class="keywords"></div>
                    </div>

                    <div class="document" data-searchable="📄 fischertechnik aps-dokumentation analyse 📋 dokumentations-übersicht dokument: dokumentation_aps_de-02-2025.rtf version: 4.0 model revision: 1.x datum: februar 2025 sprache: deutsch 🎯 wichtige erkenntnisse aus der dokumentation 🏭 system-architektur zentrale komponenten: - raspberry pi 4b : herzstück des systems mit zentraler steuerungssoftware - mqtt-broker : port 1883 auf 192.168.0.100 default/default - node-red : port 1880 auf 192.168.0.100 gateway zwischen opc-ua und mqtt - router : tp-link tl-wr902ac 192.168.0.1, admin/admin1 modul-controller: - txt 4.0 controller : kommuniziert via mqtt mit zentraler steuerung - sps s7-1200 : individueller opc-ua server pro modul 📡 netzwerk-konfiguration ip-adressen der module: mill: 192.168.0.40-45 ✅ in unserer aps vorhanden drill: 192.168.0.50-55 ✅ in unserer aps vorhanden oven: 192.168.0.60-65 ❌ optional - nicht in unserer aps aiqs: 192.168.0.70-75 ✅ in unserer aps vorhanden hbw: 192.168.0.80-83 ✅ in unserer aps vorhanden dps: 192.168.0.90 ✅ i">
                        <h3><a href="analysis/fischertechnik-dokumentation-analyse.md">📄 Fischertechnik APS-Dokumentation Analyse</a></h3>
                        <p>**Dokument:** `Dokumentation_APS_DE-02-2025.rtf`</p>
                        <p><strong>📁 Pfad:</strong> analysis/fischertechnik-dokumentation-analyse.md</p>
                        <p><strong>📊 Größe:</strong> 5,979 Bytes | <strong>Wörter:</strong> 645</p>
                        <div class="keywords"></div>
                    </div>

                    <div class="document" data-searchable="🚨 mqtt order-id management strategie 📋 kritisches problem identifiziert 🚨 root cause: "orderupdateid not valid" fehler in mqtt response: { "actionstate": { "state": "failed", "command": "pick" }, "errors": { "errortype": "validation", "errormessage": "orderupdateid not valid" } } 🔍 problem-analyse: 1. order-id : wird korrekt generiert uuid 2. orderupdateid : bleibt immer 1 für alle commands 3. workflow-sequenz : pick → process → drop benötigt inkrementelle orderupdateid 4. aps-erwartung : orderupdateid muss für sequenzielle commands steigen 1, 2, 3... --- 🎯 lösungsstrategie: workflowordermanager 1. workflowordermanager klasse python import uuid from datetime import datetime from typing import dict, list, optional class workflowordermanager: def __init__ self : self.active_workflows: dict str, dict = {} self.workflow_history: list dict = def start_workflow self, module: str, commands: list str , workpiece_type: str = "white" -> str: """startet einen neuen workflow und gibt orderid zurüc">
                        <h3><a href="analysis/mqtt-order-id-management-strategie.md">🚨 MQTT ORDER-ID Management Strategie</a></h3>
                        <p>Fehler in MQTT Response:</p>
                        <p><strong>📁 Pfad:</strong> analysis/mqtt-order-id-management-strategie.md</p>
                        <p><strong>📊 Größe:</strong> 10,293 Bytes | <strong>Wörter:</strong> 925</p>
                        <div class="keywords"></div>
                    </div>

                    <div class="document" data-searchable="📊 mqtt-session-analyse ergebnisse 🎯 übersicht der systematischen analyse datum: 19. august 2025 analysierte sessions: 18 sessions gesamt-nachrichten: 13.193 mqtt-nachrichten --- 📋 session-kategorien und ergebnisse 1. 🏭 wareneingang sessions 9 sessions - gesamt-nachrichten: 4.170 - order-ids: 37 eindeutige ids - durchschnitt pro session: ~463 nachrichten, ~4 order-ids varianz-analyse: - blau: 3 sessions 1.487 nachrichten - rot: 3 sessions 1.293 nachrichten - weiß: 3 sessions 1.390 nachrichten konsistente muster: - ✅ alle sessions haben 4-5 order-ids - ✅ keine status-updates erkannt modul-status-monitoring fehlt - ✅ viele command-sequenzen 421-545 pro session - ⚠️ error-nachrichten: 55-121 pro session 2. 📦 auftrag sessions 3 sessions - gesamt-nachrichten: 3.212 - order-ids: 8 eindeutige ids - durchschnitt pro session: ~1.071 nachrichten, ~2.7 order-ids ergebnisse: - blau: 1.168 nachrichten, 4 order-ids - rot: 1.045 nachrichten, 1 order-id ⚠️ - weiß: 999 nachrichten, 3 order-ids kritische">
                        <h3><a href="analysis/mqtt-session-analyse-ergebnisse.md">📊 MQTT-Session-Analyse Ergebnisse</a></h3>
                        <p>**Datum:** 19. August 2025</p>
                        <p><strong>📁 Pfad:</strong> analysis/mqtt-session-analyse-ergebnisse.md</p>
                        <p><strong>📊 Größe:</strong> 9,655 Bytes | <strong>Wörter:</strong> 1115</p>
                        <div class="keywords"></div>
                    </div>

                    <div class="document" data-searchable="📊 mqtt-session-analyse plan 🎯 analyse-ziel systematische analyse der mqtt-nachrichten während spezifischer workflows, um muster und abhängigkeiten zu identifizieren, die die mqtt-command-probleme verursachen. 📋 geplante mqtt-sessions session 1: wareneingang rot, weiß, blau ziel : verstehen der mqtt-nachrichten beim wareneingang verschiedener werkstück-typen workflow-schritte: 1. werkstück rot in wareneingang platzieren 2. mqtt-session aufnehmen während des gesamten prozesses 3. werkstück weiß in wareneingang platzieren 4. mqtt-session aufnehmen während des gesamten prozesses 5. werkstück blau in wareneingang platzieren 6. mqtt-session aufnehmen während des gesamten prozesses session-labels: - wareneingang-rot_1 , wareneingang-rot_2 , wareneingang-rot_3 - wareneingang-weiss_1 , wareneingang-weiss_2 , wareneingang-weiss_3 - wareneingang-blau_1 , wareneingang-blau_2 , wareneingang-blau_3 zu analysierende aspekte: - order-id generierung : wie werden eindeutige order-ids erstellt? - timing-">
                        <h3><a href="analysis/mqtt-session-analyse-plan.md">📊 MQTT-Session-Analyse Plan</a></h3>
                        <p>Systematische Analyse der MQTT-Nachrichten während spezifischer Workflows, um Muster und Abhängigkeiten zu identifizieren, die die MQTT-Command-Probleme verursachen.</p>
                        <p><strong>📁 Pfad:</strong> analysis/mqtt-session-analyse-plan.md</p>
                        <p><strong>📊 Größe:</strong> 7,923 Bytes | <strong>Wörter:</strong> 844</p>
                        <div class="keywords"></div>
                    </div>

                    <div class="document" data-searchable="📄 fischertechnik pdf-analyse ergebnisse 📋 analyse-status dokumentation: dokumentation_aps_de-02-2025.rtf format: rtf rich text format - erfolgreich analysiert status: ✅ vollständig analysiert - alle wichtigen informationen extrahiert 🎯 wichtige entdeckungen 1. system-architektur bestätigt - ✅ raspberry pi 4b als zentrale steuerungseinheit - ✅ mqtt-broker auf port 1883 192.168.0.100 - ✅ node-red gateway auf port 1880 für opc-ua ↔ mqtt übersetzung - ✅ tp-link router 192.168.0.1 für netzwerk-management 2. modul-ip-adressen validiert mill: 192.168.0.40-45 ✅ bestätigt drill: 192.168.0.50-55 ✅ bestätigt oven: 192.168.0.60-65 🔄 neu entdeckt aiqs: 192.168.0.70-75 ✅ bestätigt hbw: 192.168.0.80-83 ✅ bestätigt dps: 192.168.0.90 ✅ bestätigt 3. technische standards identifiziert - vda5050 : standard für fts-kommunikation - opc-ua : für sps-module port 4840 - mqtt : für txt 4.0 controller - node-red : gateway zwischen protokollen 4. zugangsdaten dokumentiert - mqtt : default/default - node-red : htt">
                        <h3><a href="analysis/pdf-analyse-ergebnisse.md">📄 Fischertechnik PDF-Analyse Ergebnisse</a></h3>
                        <p>**Dokumentation:** `Dokumentation_APS_DE-02-2025.rtf`</p>
                        <p><strong>📁 Pfad:</strong> analysis/pdf-analyse-ergebnisse.md</p>
                        <p><strong>📊 Größe:</strong> 4,641 Bytes | <strong>Wörter:</strong> 510</p>
                        <div class="keywords"></div>
                    </div>

                    <div class="document" data-searchable="📹 session-recording guide 🎯 praktische anleitung für mqtt-session-aufnahme vorbereitung 1. aps-system vorbereiten - alle module einschalten - mqtt-broker läuft 192.168.0.100:1883 - werkstücke bereitstellen rot, weiß, blau 2. session-logger vorbereiten bash cd /users/oliver/projects/orbis-modellfabrik session-recording workflow schritt 1: session starten bash session-logger starten python src_orbis/mqtt/loggers/aps_session_logger.py --session-label wareneingang-rot_1 --auto-start schritt 2: workflow durchführen - werkstück rot in wareneingang platzieren - gesamten prozess beobachten - auf fehler achten und notieren schritt 3: session beenden - "q" drücken um session zu stoppen - session-db prüfen in data/mqtt-data/sessions/ 📋 session-plan flexibel - basis + varianz bei bedarf phase 1: wareneingang basis + varianz bei bedarf bash basis-sessions 1x pro szenario python src_orbis/mqtt/loggers/aps_session_logger.py --session-label wareneingang-rot --auto-start python src_orbis/mqtt/loggers/a">
                        <h3><a href="analysis/session-recording-guide.md">📹 Session-Recording Guide</a></h3>
                        <p>1. **APS-System vorbereiten**</p>
                        <p><strong>📁 Pfad:</strong> analysis/session-recording-guide.md</p>
                        <p><strong>📊 Größe:</strong> 6,970 Bytes | <strong>Wörter:</strong> 568</p>
                        <div class="keywords"><span class="keyword">guide</span></div>
                    </div>

                </div>
            </div>

            <div class="category">
                <h2>📂 archive (4 Dokumente)</h2>
                <div class="documents">

                    <div class="document" data-searchable="chat-zusammenfassung für neue session 🎯 aktueller projektstand september 2025 ✅ abgeschlossene arbeiten 1. dashboard v3.3.0 entwicklung - neue produktionsplanung-features implementiert 2. shopfloor 3x4-grid system - vollständig implementiert mit intersection1-4 ids 3. fts route generator - yaml → mqtt message generator für fahrerloses transport system 4. produktkatalog - blau, weiß, rot produkte mit fertigungsaufträgen 5. messagegenerator integration - alle neuen features nutzen das zentrale konzept 6. umfassende tests - unit tests für alle neuen komponenten 🔧 aktuelles problem: windows alluppercase dateinamen - problem : auf windows system wurden dateien in alluppercase abgelegt - lokale dateien : alle in lowercase connection.yml, state.yml, etc. - windows dateien : vermutlich connection.yml, state.yml, etc. - auswirkung : mögliche kompatibilitätsprobleme bei der übertragung 📁 wichtige dateien und strukturen src_orbis/omf/config/ ├── message_templates/templates/ │ ├── ccu/ control.yml">
                        <h3><a href="archive/CHAT_SUMMARY_FOR_NEW_SESSION.md">Chat-Zusammenfassung für neue Session</a></h3>
                        <p>1. **Dashboard v3.3.0 Entwicklung** - Neue Produktionsplanung-Features implementiert</p>
                        <p><strong>📁 Pfad:</strong> archive/CHAT_SUMMARY_FOR_NEW_SESSION.md</p>
                        <p><strong>📊 Größe:</strong> 2,593 Bytes | <strong>Wörter:</strong> 289</p>
                        <div class="keywords"></div>
                    </div>

                    <div class="document" data-searchable="commit summary: sequenz-steuerung implementation 🎯 commit-ziel vollständige implementierung der sequenz-steuerung mit automatischer mqtt-nachrichten-ausführung, die identisch mit der factory-steuerung ist. 📋 geänderte dateien neue dateien - src_orbis/omf/dashboard/components/steering_sequence.py - dashboard-integration - src_orbis/omf/tools/sequence_ui.py - ui-komponenten - src_orbis/omf/tools/sequence_executor.py - haupt-engine - src_orbis/omf/tools/workflow_order_manager.py - order-management - src_orbis/omf/config/sequence_definitions/aiqs_sequence.py - aiqs-sequenz - tests_orbis/test_sequence_integration.py - integrationstests - tests_orbis/test_sequence_vs_factory_steering.py - validierungstests - tests_orbis/test_sequence_variable_resolution.py - variable-resolution tests - tests_orbis/test_comprehensive_sequence_errors.py - fehlerbehandlung tests - docs_orbis/sequence-control-implementation-2025-01.md - dokumentation geänderte dateien - src_orbis/omf/dashboard/components/steerin">
                        <h3><a href="archive/COMMIT_SUMMARY_SEQUENCE_CONTROL.md">Commit Summary: Sequenz-Steuerung Implementation</a></h3>
                        <p>Vollständige Implementierung der Sequenz-Steuerung mit automatischer MQTT-Nachrichten-Ausführung, die identisch mit der Factory-Steuerung ist.</p>
                        <p><strong>📁 Pfad:</strong> archive/COMMIT_SUMMARY_SEQUENCE_CONTROL.md</p>
                        <p><strong>📊 Größe:</strong> 5,181 Bytes | <strong>Wörter:</strong> 530</p>
                        <div class="keywords"></div>
                    </div>

                    <div class="document" data-searchable="import-pfad-probleme systematisch lösen problem - black formatiert relative imports zurück, aber die module existieren nicht an den erwarteten orten - modulenotfounderror bei tests und imports - pre-commit hooks schlagen fehl wegen import-problemen lösung: projekt als installierbares paket konfigurieren ✅ schritt 1: pyproject.toml erweitert - setuptools-konfiguration hinzugefügt - pytest-konfiguration hinzugefügt - isort known_first_party konfiguriert 🔄 schritt 2: editable installation bash pip install -e . zweck: macht src_orbis als top-level-package verfügbar, damit import src_orbis.omf... überall funktioniert 🔄 schritt 3: pre-commit-config.yaml anpassen yaml - id: pytest name: pytest entry: python -m pytest -q language: system pass_filenames: false ⬅️ kritisch! stages: pre-commit zweck: pytest läuft ohne dateiliste, importiert nicht versehentlich streamlit-dateien 🔄 schritt 4: sys.path manipulationen entfernen - suche nach sys.path.append in allen dateien - entferne diese, da sie na">
                        <h3><a href="archive/IMPORT_FIX_TODO.md">Import-Pfad-Probleme systematisch lösen</a></h3>
                        <p>- Black formatiert relative Imports zurück, aber die Module existieren nicht an den erwarteten Orten</p>
                        <p><strong>📁 Pfad:</strong> archive/IMPORT_FIX_TODO.md</p>
                        <p><strong>📊 Größe:</strong> 2,390 Bytes | <strong>Wörter:</strong> 282</p>
                        <div class="keywords"></div>
                    </div>

                    <div class="document" data-searchable="orbis modellfabrik dashboard ein umfassendes dashboard für die orbis modellfabrik mit mqtt-nachrichtenüberwachung und replay-funktionalität. 🎯 projekt-ziel entwicklung einer eigenen steuerungsanwendung für die aps fischertechnik miniatur-fabrik durch analyse der bestehenden nachrichten-kommunikation. 🏭 aps-fischertechnik system - reale miniatur-fabrik mit verschiedenen modulen - software zur steuerung der fabrik-prozesse wareneingang, produktion nach bestellung - ziel: verständnis der funktionsweise für eigene steuerungsanwendung 🚀 entwicklungsphasen 1. session-rekording ✅ - aufnahme der mqtt-nachrichten-ströme 2. session-analyse 🔄 - semantik und funktionsweise verstehen 3. steuerungs-entwicklung 📋 - omf dashboard für fabrik-steuerung > 📖 detaillierte projekt-übersicht: project_overview.md docs_orbis/project_overview.md 📋 entwicklungsregeln > 🎯 wichtig: bevor sie mit der entwicklung beginnen, lesen sie die entwicklungsregeln docs_orbis/development_rules.md ! - import-standards: nur abs">
                        <h3><a href="archive/README_current.md">ORBIS Modellfabrik Dashboard</a></h3>
                        <p>Ein umfassendes Dashboard für die ORBIS Modellfabrik mit MQTT-Nachrichtenüberwachung und Replay-Funktionalität.</p>
                        <p><strong>📁 Pfad:</strong> archive/README_current.md</p>
                        <p><strong>📊 Größe:</strong> 6,886 Bytes | <strong>Wörter:</strong> 685</p>
                        <div class="keywords"><span class="keyword">overview</span></div>
                    </div>

                </div>
            </div>

            <div class="category">
                <h2>📂 guides (13 Dokumente)</h2>
                <div class="documents">

                    <div class="document" data-searchable="mqtt integration guide 📋 overview das omf dashboard verwendet die per-topic-buffer architektur für mqtt-nachrichtenverarbeitung. diese moderne architektur kombiniert das mqtt-singleton pattern mit effizienten per-topic-buffers für optimale performance und einfachheit. ✅ aktuelle mqtt architektur 1. mqtt-singleton pattern - eine mqtt-client-instanz pro streamlit-session - zentraler zugriff über st.session_state "mqtt_client" - automatische verbindung beim dashboard-start - umgebungswechsel live/mock/replay ohne verbindungsabbruch 2. per-topic-buffer system - topic-spezifische buffer für jede mqtt-subscription - automatische nachrichtensammlung in separaten buffers - effiziente verarbeitung ohne message-processor overhead - direkte buffer-zugriffe für optimale performance 3. hybrid-architektur für publishing - messagegenerator für payload-erstellung - session state für preview/edit-funktionalität - mqttgateway für finales publishing - workflowordermanager für orderid/orderupdateid verwal">
                        <h3><a href="guides/communication/MQTT_INTEGRATION_GUIDE.md">MQTT Integration Guide</a></h3>
                        <p>Das **OMF Dashboard** verwendet die **Per-Topic-Buffer Architektur** für MQTT-Nachrichtenverarbeitung. Diese moderne Architektur kombiniert das **MQTT-Singleton Pattern** mit effizienten **Per-Topic-B...</p>
                        <p><strong>📁 Pfad:</strong> guides/communication/MQTT_INTEGRATION_GUIDE.md</p>
                        <p><strong>📊 Größe:</strong> 3,734 Bytes | <strong>Wörter:</strong> 365</p>
                        <div class="keywords"><span class="keyword">guide</span></div>
                    </div>

                    <div class="document" data-searchable="dashboard icon integration ⚠️ veraltet - aps dashboard übersicht ⚠️ veraltet das aps dashboard wurde mit umfassenden icon-features erweitert, um eine intuitive und visuell ansprechende benutzeroberfläche zu bieten. ⚠️ hinweis: diese dokumentation bezieht sich auf das veraltete aps dashboard. die icon-integration wurde in das neue omf dashboard übernommen. implementierte features 🎨 icon-system module icons - mill: ⚙️ gear - drill: 🔩 nut&bolt - hbw: 🏬 department store - aiqs: 🤖 robot - dps: 📦 package - fts: 🚗 car - chrg: 🔋 battery - oven: 🔥 fire status icons - available: ✅ - busy: ⚠️ - blocked: ❌ - charging: ⚡ - transport: 🚗 - maintenance: 🔧 - idle: 😴 - ready: 🎯 system icons - rpi: 🖥️ - txt: 🎮 - router: 🌐 - mqtt: 📡 📍 integration module overview - emoji-icons in der modul-tabelle - status-icons für activity status - connection status mit icons mqtt control - module-headers mit icons - status-anzeigen mit erweiterten icons - button-icons für befehle sidebar - orbis logo integration - mqtt ">
                        <h3><a href="guides/communication/mqtt/dashboard-icon-integration.md">Dashboard Icon Integration ⚠️ **VERALTET - APS Dashboard**</a></h3>
                        <p>Das APS Dashboard wurde mit umfassenden Icon-Features erweitert, um eine intuitive und visuell ansprechende Benutzeroberfläche zu bieten.</p>
                        <p><strong>📁 Pfad:</strong> guides/communication/mqtt/dashboard-icon-integration.md</p>
                        <p><strong>📊 Größe:</strong> 2,055 Bytes | <strong>Wörter:</strong> 252</p>
                        <div class="keywords"></div>
                    </div>

                    <div class="document" data-searchable="🔗 mqtt integration - omf dashboard 📋 overview das omf dashboard verwendet die per-topic-buffer architektur für mqtt-nachrichtenverarbeitung. diese moderne architektur kombiniert das mqtt-singleton pattern mit effizienten per-topic-buffers für optimale performance und einfachheit. ✅ aktuelle mqtt architektur 1. mqtt-singleton pattern - eine mqtt-client-instanz pro streamlit-session - zentraler zugriff über st.session_state "mqtt_client" - automatische verbindung beim dashboard-start - umgebungswechsel live/mock/replay ohne verbindungsabbruch 2. per-topic-buffer system - topic-spezifische buffer für jede mqtt-subscription - automatische nachrichtensammlung in separaten buffers - effiziente verarbeitung ohne message-processor overhead - direkte buffer-zugriffe für optimale performance 3. hybrid-architektur für publishing - messagegenerator für payload-erstellung - session state für preview/edit-funktionalität - mqttgateway für finales publishing - workflowordermanager für orderid/orderupd">
                        <h3><a href="guides/communication/mqtt/dashboard-mqtt-integration.md">🔗 MQTT Integration - OMF Dashboard</a></h3>
                        <p>Das **OMF Dashboard** verwendet die **Per-Topic-Buffer Architektur** für MQTT-Nachrichtenverarbeitung. Diese moderne Architektur kombiniert das **MQTT-Singleton Pattern** mit effizienten **Per-Topic-B...</p>
                        <p><strong>📁 Pfad:</strong> guides/communication/mqtt/dashboard-mqtt-integration.md</p>
                        <p><strong>📊 Größe:</strong> 11,205 Bytes | <strong>Wörter:</strong> 1088</p>
                        <div class="keywords"></div>
                    </div>

                    <div class="document" data-searchable="🎯 mqtt control summary - fischertechnik aps 📋 executive summary we have successfully analyzed, tested, and documented the mqtt control capabilities of the fischertechnik aps model factory. through systematic testing, we discovered working mqtt messages and created a comprehensive library for reliable module control. ✅ key achievements 1. working mqtt messages discovered - ✅ drill pick command : successfully tested and working - ✅ message library created : reusable templates for all modules - ✅ enhanced controllers : updated tools with working messages 2. module control capabilities - direct control : pick, drop, store, check_quality commands work - automatic control : mill/drill commands are handled by aps system - authentication : default / default credentials required 3. tools and scripts created - mqtt_message_library.py : centralized working message library - aps_enhanced_controller.py : enhanced controller using library - module_test_suite.py : comprehensive test suite - updated r">
                        <h3><a href="guides/communication/mqtt/mqtt-control-summary.md">🎯 MQTT Control Summary - Fischertechnik APS</a></h3>
                        <p>We have successfully **analyzed, tested, and documented** the MQTT control capabilities of the Fischertechnik APS model factory. Through systematic testing, we discovered **working MQTT messages** and...</p>
                        <p><strong>📁 Pfad:</strong> guides/communication/mqtt/mqtt-control-summary.md</p>
                        <p><strong>📊 Größe:</strong> 7,554 Bytes | <strong>Wörter:</strong> 941</p>
                        <div class="keywords"></div>
                    </div>

                    <div class="document" data-searchable="📡 nachrichtenzentrale - implementation 📋 übersicht die nachrichtenzentrale ist ein neuer tab im omf dashboard, der alle mqtt-nachrichten der modellfabrik anzeigt. sie bietet eine übersichtliche darstellung von gesendeten und empfangenen nachrichten mit umfassenden filter-optionen. 🏗️ architektur ✅ komponenten-struktur: 📡 nachrichtenzentrale ├── 🎯 omfmqttclient mqtt-client mit singleton-pattern ├── 🔍 filter-system modul, kategorie, zeitraum, topic ├── 📊 nachrichten-tabelle gesendet/empfangen └── 🔄 auto-refresh konfigurierbar ✅ datei-struktur: src_orbis/omf/dashboard/components/ ├── message_center.py haupt-komponente └── weitere komponenten tests_orbis/ └── test_message_center.py unit-tests 🎯 funktionalität ✅ 1. nachrichten-anzeige: - zwei tabs: gesendete und empfangene nachrichten - neueste zuerst: chronologische sortierung desc - pagination: automatische begrenzung auf 1000 nachrichten - real-time: live-updates über mqtt ✅ 2. filter-system: python verfügbare filter: - 🏭 module: hbw, ft">
                        <h3><a href="guides/communication/mqtt/nachrichtenzentrale-implementation.md">📡 Nachrichtenzentrale - Implementation</a></h3>
                        <p>Die **Nachrichtenzentrale** ist ein neuer Tab im OMF Dashboard, der alle MQTT-Nachrichten der Modellfabrik anzeigt. Sie bietet eine übersichtliche Darstellung von gesendeten und empfangenen Nachrichte...</p>
                        <p><strong>📁 Pfad:</strong> guides/communication/mqtt/nachrichtenzentrale-implementation.md</p>
                        <p><strong>📊 Größe:</strong> 6,010 Bytes | <strong>Wörter:</strong> 591</p>
                        <div class="keywords"></div>
                    </div>

                    <div class="document" data-searchable="remote control guide - fischertechnik aps von macos dieser guide erklärt, wie du die fischertechnik aps in der firma von deinem macos-rechner aus steuern kannst. 🎯 übersicht setup: macos cursor → remote mqtt client → firmennetzwerk → fischertechnik aps vorteile: - ✅ entwicklung auf macos mit cursor - ✅ direkte steuerung der echten module - ✅ realistische tests mit echter hardware - ✅ keine hardware auf macos nötig 🔧 voraussetzungen 1. netzwerkverbindung - beide rechner im gleichen firmennetzwerk - oder vpn-verbindung zur firma - mqtt broker erreichbar port 1883 2. ip-adresse der fischertechnik aps bash in der firma ermitteln: auf dem raspberry pi oder firmenlaptop hostname -i oder ip addr show 3. mqtt broker konfiguration - mqtt broker läuft auf der fischertechnik aps - port 1883 ist offen - keine firewall-blockierung 🚀 schnellstart 1. ip-adresse ermitteln bash in der firma auf dem fischertechnik system hostname -i beispiel: 192.168.1.100 2. verbindung testen bash von macos aus ping 19">
                        <h3><a href="guides/communication/mqtt/setup/remote-control-guide.md">Remote Control Guide - Fischertechnik APS von macOS</a></h3>
                        <p>Dieser Guide erklärt, wie du die Fischertechnik APS in der Firma von deinem macOS-Rechner aus steuern kannst.</p>
                        <p><strong>📁 Pfad:</strong> guides/communication/mqtt/setup/remote-control-guide.md</p>
                        <p><strong>📊 Größe:</strong> 6,078 Bytes | <strong>Wörter:</strong> 684</p>
                        <div class="keywords"><span class="keyword">guide</span></div>
                    </div>

                    <div class="document" data-searchable="mqtt traffic logging guide - fischertechnik aps dieser guide erklärt, wie du den mqtt-traffic zwischen fischertechnik cloud und lokaler aps überwachen und analysieren kannst. 🎯 übersicht architektur mit traffic logging: fischertechnik cloud ←→ mqtt bridge logger ←→ txt 4.0 controller ←→ module ↓ traffic logging ↓ log files + database comprehensive monitoring empfohlen : raspberry pi broker 192.168.0.100 ←→ comprehensive logger ←→ alle nachrichten secondary broker 192.168.2.189 ←→ comprehensive logger ←→ alle nachrichten docker broker host.docker.internal ←→ comprehensive logger ←→ alle nachrichten container broker mqtt-broker ←→ comprehensive logger ←→ alle nachrichten ↓ vollständige transparenz ↓ log files + database + analysis vorteile: - ✅ vollständige transparenz über alle mqtt-nachrichten - ✅ non-intrusive - keine änderung am bestehenden system - ✅ real-time monitoring mit statistiken - ✅ detaillierte analyse mit visualisierungen - ✅ debugging von kommunikationsproblemen - ✅ alle ">
                        <h3><a href="guides/communication/mqtt/setup/traffic-logging-guide.md">MQTT Traffic Logging Guide - Fischertechnik APS</a></h3>
                        <p>Dieser Guide erklärt, wie du den MQTT-Traffic zwischen Fischertechnik Cloud und lokaler APS überwachen und analysieren kannst.</p>
                        <p><strong>📁 Pfad:</strong> guides/communication/mqtt/setup/traffic-logging-guide.md</p>
                        <p><strong>📊 Größe:</strong> 9,860 Bytes | <strong>Wörter:</strong> 918</p>
                        <div class="keywords"><span class="keyword">guide</span></div>
                    </div>

                    <div class="document" data-searchable="state machine notes für mqtt message templates fts fahrerloses transportsystem - 5io4 zustandsautomat-verhalten findinitialdockposition - verfügbarkeit : nur nach initialisierung verfügbar - verhalten : wird nach ausführung deaktiviert - zweck : initiale positionsfindung für fts - fischertechnik-dashboard : button wird nach initialisierung deaktiviert startcharging / stopcharging - verhalten : gegenseitig ausschließend - zustandsautomat : - wenn startcharging aktiv → stopcharging verfügbar, startcharging deaktiviert - wenn stopcharging aktiv → startcharging verfügbar, stopcharging deaktiviert - zweck : verhindert gleichzeitige ladung und ladestopp factsheetrequest - verfügbarkeit : immer verfügbar - zweck : status-abfrage für dynamische button-aktivierung - zukunft : wird für status-verwaltung verwendet implementierungsnotizen aktueller stand - alle fts-befehle sind immer verfügbar einfache implementierung - keine status-verwaltung implementiert geplante erweiterungen - status-verwaltu">
                        <h3><a href="guides/communication/mqtt/state-machine-notes.md">State Machine Notes für MQTT Message Templates</a></h3>
                        <p>- **Verfügbarkeit**: Nur nach Initialisierung verfügbar</p>
                        <p><strong>📁 Pfad:</strong> guides/communication/mqtt/state-machine-notes.md</p>
                        <p><strong>📊 Größe:</strong> 3,029 Bytes | <strong>Wörter:</strong> 339</p>
                        <div class="keywords"></div>
                    </div>

                    <div class="document" data-searchable="🏭 module configuration guide 📋 overview die zentrale modul-konfiguration wurde erfolgreich implementiert und ersetzt die veraltete module_mapping.json durch eine moderne yaml-basierte lösung mit erweiterten funktionen. ✅ neue features 1. zentrale yaml-konfiguration - datei : src_orbis/mqtt/config/module_config.yml - format : yaml für bessere lesbarkeit und wartung - struktur : hierarchische organisation nach modul-typen 2. modulemanager klasse - datei : src_orbis/mqtt/tools/module_manager.py - funktionen : einheitliche verwaltung für alle tools - backward compatibility : bestehende funktionen bleiben verfügbar 3. dashboard integration - neuer tab : "🏭 module" unter "einstellungen" - anzeige : tabellarische darstellung nach modul-typen - ip-ranges : vollständige ip-adressen-übersicht 🏭 modul-übersicht vollständige modul-konfiguration: | modul | serial number | typ | ip-range | ip-adressen | befehle | |-------|---------------|-----|----------|-------------|---------| | hbw | svr3qa0022 |">
                        <h3><a href="guides/configuration/module-configuration-guide.md">🏭 Module Configuration Guide</a></h3>
                        <p>Die **zentrale Modul-Konfiguration** wurde erfolgreich implementiert und ersetzt die veraltete `module_mapping.json` durch eine moderne YAML-basierte Lösung mit erweiterten Funktionen.</p>
                        <p><strong>📁 Pfad:</strong> guides/configuration/module-configuration-guide.md</p>
                        <p><strong>📊 Größe:</strong> 9,217 Bytes | <strong>Wörter:</strong> 937</p>
                        <div class="keywords"><span class="keyword">guide</span></div>
                    </div>

                    <div class="document" data-searchable="nfc code configuration guide übersicht die nfc-code-konfiguration wurde zentralisiert und verwendet eine yaml-konfigurationsdatei für alle nfc-code-bezogenen operationen im orbis-projekt. 📁 konfigurationsdatei pfad: src_orbis/mqtt/config/nfc_code_config.yml struktur yaml metadata: version: "2.0" description: "nfc code mapping mit erweiterten informationen" last_updated: "2025-08-27" author: "orbis development team" nfc_codes: "040a8dca341291": friendly_id: "r1" color: "red" quality_check: "ok" description: "rotes werkstück 1" ... weitere nfc-codes quality_check_options: - "ok" - "not-ok" - "pending" - "failed" colors: - "red" - "white" - "blue" template_placeholders: nfc_code: "<nfccode>" workpiece_id: "<workpieceid>" color: "<color>" quality: "<quality>" mqtt_paths: - "workpieceid" - "metadata", "workpiece", "workpieceid" - "action", "metadata", "workpiece", "workpieceid" - "workpiece", "workpieceid" - "loadid" - "id" 🔧 nfccodemanager klasse verwendung python from src_orbis.mqtt.tools">
                        <h3><a href="guides/configuration/nfc-code-configuration-guide.md">NFC Code Configuration Guide</a></h3>
                        <p>Die NFC-Code-Konfiguration wurde zentralisiert und verwendet eine YAML-Konfigurationsdatei für alle NFC-Code-bezogenen Operationen im ORBIS-Projekt.</p>
                        <p><strong>📁 Pfad:</strong> guides/configuration/nfc-code-configuration-guide.md</p>
                        <p><strong>📊 Größe:</strong> 4,433 Bytes | <strong>Wörter:</strong> 443</p>
                        <div class="keywords"><span class="keyword">guide</span></div>
                    </div>

                    <div class="document" data-searchable="topic-konfiguration guide übersicht die topic-konfiguration ist eine zentrale verwaltung aller mqtt-topics für die orbis modellfabrik. sie ersetzt verstreute topic-mappings und bietet eine einheitliche struktur für alle topic-bezogenen informationen. dateien konfigurationsdatei: - pfad : src_orbis/mqtt/config/topic_config.yml - zweck : zentrale yaml-konfiguration aller mqtt-topics manager-klasse: - pfad : src_orbis/mqtt/tools/topic_manager.py - zweck : python-klasse für topic-verwaltung und -abfragen struktur topic-kategorien: 1. ccu central control unit - icon : 🏭 - beschreibung : zentrale steuerungseinheit - koordiniert alle module und workflows - topics : 10 topics für status, steuerung und verbindung - sub-kategorien : state, control, status 2. txt txt 4.0 controller - icon : 🎛️ - beschreibung : fischertechnik controller für sensorik und aktorik - topics : 17 topics für input/output, sensoren und broadcast - sub-kategorien : function input, function output, control, input, output 3">
                        <h3><a href="guides/configuration/topic-configuration-guide.md">Topic-Konfiguration Guide</a></h3>
                        <p>Die Topic-Konfiguration ist eine zentrale Verwaltung aller MQTT-Topics für die ORBIS Modellfabrik. Sie ersetzt verstreute Topic-Mappings und bietet eine einheitliche Struktur für alle Topic-bezogenen ...</p>
                        <p><strong>📁 Pfad:</strong> guides/configuration/topic-configuration-guide.md</p>
                        <p><strong>📊 Größe:</strong> 10,091 Bytes | <strong>Wörter:</strong> 1095</p>
                        <div class="keywords"><span class="keyword">guide</span></div>
                    </div>

                    <div class="document" data-searchable="black/ruff loop problem - pre-commit hooks problem: black/ruff loop bei pre-commit hooks symptom: - pre-commit hooks laufen in einer endlosschleife - black formatiert immer wieder die gleiche datei: src_orbis/omf/config/sequence_definitions/aiqs_sequence.py - ruff zeigt "all checks passed!" aber black formatiert trotzdem aktuelle ausgaben: black output: black....................................................................failed - hook id: black - files were modified by this hook reformatted src_orbis/omf/config/sequence_definitions/aiqs_sequence.py ruff output: ruff.....................................................................passed pytest output: 413 passed, 18 warnings in 23.45s problem-datei: src_orbis/omf/config/sequence_definitions/aiqs_sequence.py aktueller inhalt zeilen 6-8 : python fmt: off from src_orbis.omf.tools.sequence_executor import sequencedefinition, sequencestep fmt: on was passiert: 1. black formatiert die datei und entfernt die fmt: off/on kommentare 2. b">
                        <h3><a href="guides/troubleshooting/BLACK_RUFF_LOOP_PROBLEM.md">Black/Ruff Loop Problem - Pre-commit Hooks</a></h3>
                        <p>- Pre-commit Hooks laufen in einer Endlosschleife</p>
                        <p><strong>📁 Pfad:</strong> guides/troubleshooting/BLACK_RUFF_LOOP_PROBLEM.md</p>
                        <p><strong>📊 Größe:</strong> 2,282 Bytes | <strong>Wörter:</strong> 231</p>
                        <div class="keywords"></div>
                    </div>

                    <div class="document" data-searchable="critical bug fix: module-id mapping error 🚨 kritischer bug behoben datum: 2025-01-19 betroffene versionen: dashboardv3.1.0, dashboardv3.1.1 schweregrad: kritisch 📋 problem-beschreibung: was passierte: - befehl: drill-pick ausgeführt - tatsächlich ausgelöst: aiqs-pick - ursache: falsche module-id-zuordnung in steering_factory.py betroffene module: - drill bekam fälschlicherweise aiqs-seriennummer svr4h76530 - aiqs bekam fälschlicherweise mill-seriennummer svr3qa2098 - mill bekam fälschlicherweise drill-seriennummer svr4h76449 🔧 behobene datei: datei: src_orbis/omf/dashboard/components/steering_factory.py funktion: _get_module_serial zeile 198 ❌ vorher falsch : python def _get_module_serial module_name: str -> str: """hilfsfunktion um module-serials zu bekommen""" module_serials = {"aiqs": "svr3qa2098", "mill": "svr4h76449", "drill": "svr4h76530"} return module_serials.get module_name, "unknown" ✅ nachher korrekt : python def _get_module_serial module_name: str -> str: """hilfsfunktion u">
                        <h3><a href="guides/troubleshooting/critical-bug-fix-module-id-mapping.md">Critical Bug Fix: Module-ID Mapping Error</a></h3>
                        <p>**Datum:** 2025-01-19</p>
                        <p><strong>📁 Pfad:</strong> guides/troubleshooting/critical-bug-fix-module-id-mapping.md</p>
                        <p><strong>📊 Größe:</strong> 3,084 Bytes | <strong>Wörter:</strong> 318</p>
                        <div class="keywords"></div>
                    </div>

                </div>
            </div>

            <div class="category">
                <h2>📂 helper_apps (1 Dokumente)</h2>
                <div class="documents">

                    <div class="document" data-searchable="🎬 omf replay station - konzept 📋 übersicht die omf replay station ist eine separate anwendung, die als lokaler mqtt-broker fungiert und aufgezeichnete session-daten 1:1 wiedergibt. dies ermöglicht realistische tests ohne echte aps-modellfabrik-verbindung. 🏗️ architektur ✅ komponenten-struktur: 🎬 omf replay station ├── 📡 lokaler mqtt-broker localhost:1884 ├── 🎮 session player ├── ⏱️ replay controller └── 📊 session manager 📊 omf dashboard ├── 🔗 mqtt-client → localhost:1884 replay-modus ├── 📡 nachrichtenzentrale └── 🎯 normale dashboard-funktionen ✅ datenfluss: session-datei .db/.log → session player → lokaler broker → dashboard 🎯 funktionalität ✅ 1. session-player: - session-loading: sqlite-db oder log-dateien laden - message-parsing: nachrichten mit timestamps extrahieren - timing-replay: original-nachrichtenfolgen mit korrektem timing ✅ 2. replay-controller: - play/pause: replay starten/stoppen - speed-control: 0.1x - 5x geschwindigkeit - loop-modus: endlose wiederholung - filter-replay">
                        <h3><a href="helper_apps/omf-replay-station-concept.md">🎬 OMF Replay Station - Konzept</a></h3>
                        <p>Die **OMF Replay Station** ist eine separate Anwendung, die als lokaler MQTT-Broker fungiert und aufgezeichnete Session-Daten 1:1 wiedergibt. Dies ermöglicht realistische Tests ohne echte APS-Modellfa...</p>
                        <p><strong>📁 Pfad:</strong> helper_apps/omf-replay-station-concept.md</p>
                        <p><strong>📊 Größe:</strong> 4,869 Bytes | <strong>Wörter:</strong> 500</p>
                        <div class="keywords"></div>
                    </div>

                </div>
            </div>

            <div class="category">
                <h2>📂 node-red (3 Dokumente)</h2>
                <div class="documents">

                    <div class="document" data-searchable="node-red documentation this section contains comprehensive documentation for the node-red flows that power the orbis agile production simulation system. 📋 documentation index flows overview ./flows-overview.md - tab structure and organization - module-specific flows mill, drill, oven, aiqs, hbw, dps - flow grouping and organization state machine ./state-machine.md - vda 5050 compliant state transitions - action states: pending → running → finished/failed - connection states: online/offline/connectionbroken - error handling and recovery 🔧 quick reference system components - 25 production modules across 5 types - central control unit raspberry pi - mqtt broker 192.168.2.189:1883 - opc-ua network 192.168.0.x:4840 key files - flows.json - main node-red configuration - settings.js - node-red settings - environment variables for configuration access points - node-red ui : http://192.168.0.100:1880/ - ssh access : ff22 / ff22+ - mqtt topics : module/v1/ff/{serialnumber}/{action} 🚀 getting sta">
                        <h3><a href="node-red/README.md">Node-RED Documentation</a></h3>
                        <p>This section contains comprehensive documentation for the Node-RED flows that power the Orbis Agile Production Simulation system.</p>
                        <p><strong>📁 Pfad:</strong> node-red/README.md</p>
                        <p><strong>📊 Größe:</strong> 1,622 Bytes | <strong>Wörter:</strong> 206</p>
                        <div class="keywords"><span class="keyword">overview</span></div>
                    </div>

                    <div class="document" data-searchable="node-red flows overview this document provides a comprehensive overview of the node-red flows structure in the orbis agile production simulation system. 📋 system architecture the node-red system consists of 25 main tabs plus initialization and utility flows, implementing a vda 5050 compliant state machine for industrial automation. flow categories 1. initialization 1 tab 2. production modules 23 tabs 3. central systems 1 tab 🏭 production modules mill modules 5 units | module | tab id | opc-ua endpoint | function | |--------|--------|-----------------|----------| | mill 1 | 9810df827082ae56 | 192.168.0.40:4840 | primary milling operations | | mill 2 | f6c8f50b75376b12 | 192.168.0.41:4840 | secondary milling operations | | mill 3 | 05a427a07096ebdb | 192.168.0.42:4840 | tertiary milling operations | | mill 4 | a0e5f985232949c9 | 192.168.0.43:4840 | quaternary milling operations | | mill 5 | 5fc4fbd01fd96575 | 192.168.0.44:4840 | quinary milling operations | key features: - milling operat">
                        <h3><a href="node-red/flows-overview.md">Node-RED Flows Overview</a></h3>
                        <p>This document provides a comprehensive overview of the Node-RED flows structure in the Orbis Agile Production Simulation system.</p>
                        <p><strong>📁 Pfad:</strong> node-red/flows-overview.md</p>
                        <p><strong>📊 Größe:</strong> 6,186 Bytes | <strong>Wörter:</strong> 815</p>
                        <div class="keywords"></div>
                    </div>

                    <div class="document" data-searchable="state machine documentation this document describes the vda 5050 compliant state machine implemented in the orbis agile production simulation system. 🔄 state machine overview the system implements a sophisticated state machine that manages the lifecycle of production actions, module connections, and error conditions. this follows the vda 5050 standard for autonomous mobile robots and industrial automation. 📊 action states primary action states | state | description | color | next states | |-------|-------------|-------|-------------| | pending | action received, waiting to start | 🟡 yellow | running, failed | | running | action currently executing | 🟡 yellow | finished, failed | | finished | action completed successfully | 🟢 green | pending | | failed | action failed with errors | 🔴 red | pending | state transition flow pending → running → finished ↓ ↓ failed ← failed state implementation pending state javascript // action received and validated actionstate.state = "pending"; actionsta">
                        <h3><a href="node-red/state-machine.md">State Machine Documentation</a></h3>
                        <p>This document describes the **VDA 5050 compliant state machine** implemented in the Orbis Agile Production Simulation system.</p>
                        <p><strong>📁 Pfad:</strong> node-red/state-machine.md</p>
                        <p><strong>📊 Größe:</strong> 8,193 Bytes | <strong>Wörter:</strong> 986</p>
                        <div class="keywords"></div>
                    </div>

                </div>
            </div>

            <div class="category">
                <h2>📂 releases (6 Dokumente)</h2>
                <div class="documents">

                    <div class="document" data-searchable="release notes verfahren 📋 einheitliches format dateiname-konvention: dashboardvx.y.z-release-notes.md beispiele: - dashboardv3.4.0-release-notes.md - dashboardv3.3.1-release-notes.md - dashboardv3.2.0-release-notes.md header-format: markdown omf dashboard vx.y.z - release notes datum: dd. monat yyyy version: x.y.z codename: "kurze beschreibung" status: ✅ released / 🚧 in development / 🚨 critical fix 🔄 standardisierte sektionen 1. obligatorische sektionen: - 🎯 übersicht - kurze beschreibung der wichtigsten änderungen - ✨ neue features - neue funktionalitäten - 🐛 bug fixes - behobene probleme - 🧪 testing & quality assurance - tests und qualitätssicherung 2. optionale sektionen: - 🔄 verbesserungen - performance, ui/ux verbesserungen - 📚 dokumentation - neue/aktualisierte dokumentation - 🚀 deployment - installation und konfiguration - 🎯 nächste schritte - geplante features und bekannte issues - 📊 technische details - architektur, api, dependencies 📝 schreibregeln emojis verwenden: - 🎯 übers">
                        <h3><a href="releases/RELEASE_NOTES_PROCEDURE.md">Release Notes Verfahren</a></h3>
                        <p>dashboardvX.Y.Z-release-notes.md</p>
                        <p><strong>📁 Pfad:</strong> releases/RELEASE_NOTES_PROCEDURE.md</p>
                        <p><strong>📊 Größe:</strong> 3,527 Bytes | <strong>Wörter:</strong> 400</p>
                        <div class="keywords"><span class="keyword">release</span></div>
                    </div>

                    <div class="document" data-searchable="omf dashboard vx.y.z - release notes datum: dd. monat yyyy version: x.y.z codename: "kurze beschreibung" status: ✅ released / 🚧 in development / 🚨 critical fix 🎯 übersicht kurze beschreibung der wichtigsten änderungen und verbesserungen in dieser version. ✨ neue features 📦 feature-kategorie 1 - spezifisches feature - beschreibung - weiteres feature - beschreibung 🔧 feature-kategorie 2 - spezifisches feature - beschreibung 🐛 bug fixes 🚨 critical fixes - problem: beschreibung des problems - lösung: beschreibung der lösung - betroffen: welche komponenten sind betroffen 🔧 minor fixes - problem: beschreibung - lösung: beschreibung 🔄 verbesserungen 🚀 performance - verbesserung - beschreibung 🎨 ui/ux - verbesserung - beschreibung 🧪 testing & quality assurance ✅ unit tests - neue tests - beschreibung - test-coverage - prozent 🔍 integration tests - getestete komponenten - liste 📚 dokumentation 📖 neue dokumentation - dokument - beschreibung 🔄 aktualisierte dokumentation - dokument - was wurde ge">
                        <h3><a href="releases/RELEASE_NOTES_TEMPLATE.md">OMF Dashboard vX.Y.Z - Release Notes</a></h3>
                        <p>**Datum:** DD. Monat YYYY</p>
                        <p><strong>📁 Pfad:</strong> releases/RELEASE_NOTES_TEMPLATE.md</p>
                        <p><strong>📊 Größe:</strong> 2,165 Bytes | <strong>Wörter:</strong> 248</p>
                        <div class="keywords"><span class="keyword">release</span></div>
                    </div>

                    <div class="document" data-searchable="omf dashboard v3.1.2 - release notes datum: 19. januar 2025 version: 3.1.2 codename: "critical module-id fix" status: 🚨 critical fix 🚨 critical bug fixes module-id mapping error critical - problem: drill-pick löste fälschlicherweise aiqs-pick aus - ursache: falsche seriennummer-zuordnung in _get_module_serial funktion - lösung: korrekte module-id-mapping implementiert - betroffene module: - drill: svr4h76449 ✅ war fälschlicherweise svr4h76530 - aiqs: svr4h76530 ✅ war fälschlicherweise svr3qa2098 - mill: svr3qa2098 ✅ war fälschlicherweise svr4h76449 module sequence pick → process → drop - status: ✅ repariert - funktionalität: module-sequenzen funktionieren jetzt korrekt - testing: erfolgreich getestet mit allen modulen 🧪 quality assurance unit tests hinzugefügt - neue test-datei: tests_orbis/test_module_id_mapping.py - 9 test-cases für module-id-mapping - kritische bug-prävention implementiert - alle tests: ✅ passed test coverage - ✅ module-seriennummer-zuordnung - ✅ eindeutigkeit der s">
                        <h3><a href="releases/dashboardv3.1.2-release-notes.md">OMF Dashboard v3.1.2 - Release Notes</a></h3>
                        <p>**Datum:** 19. Januar 2025</p>
                        <p><strong>📁 Pfad:</strong> releases/dashboardv3.1.2-release-notes.md</p>
                        <p><strong>📊 Größe:</strong> 3,047 Bytes | <strong>Wörter:</strong> 334</p>
                        <div class="keywords"><span class="keyword">release</span></div>
                    </div>

                    <div class="document" data-searchable="omf dashboard v3.2.0 - release notes datum: 5. september 2025 version: 3.2.0 codename: "fts & ccu monitoring" status: ✅ released 🎯 übersicht dashboard v3.2.0 introduces comprehensive fts and ccu monitoring capabilities with robust template validation, enhanced message processing, and improved user experience. ✨ neue features fts fahrerloses transportsystem tab - complete fts monitoring with 5 sub-tabs: - fts_order - fts navigation orders and commands - fts_instantaction - instant actions reset, clearloadhandler, etc. - fts_state - current fts state and position - fts_connection - connection status and health - fts_factsheet - fts configuration and specifications - semantic analysis for all fts mqtt topics - template validation with error tracking - real-time data display with timestamps ccu central control unit tab - complete ccu monitoring with 5 sub-tabs: - ccu_state - ccu system state and inventory - ccu_control - control commands and orders - ccu_set - configuration and reset comma">
                        <h3><a href="releases/dashboardv3.2.0-release-notes.md">OMF Dashboard v3.2.0 - Release Notes</a></h3>
                        <p>**Datum:** 5. September 2025</p>
                        <p><strong>📁 Pfad:</strong> releases/dashboardv3.2.0-release-notes.md</p>
                        <p><strong>📊 Größe:</strong> 7,190 Bytes | <strong>Wörter:</strong> 863</p>
                        <div class="keywords"><span class="keyword">release</span></div>
                    </div>

                    <div class="document" data-searchable="omf dashboard v3.3.0 - release notes datum: 4. januar 2025 version: 3.3.0 codename: "dashboard-komponenten-erweiterung" 🎯 übersicht diese version erweitert das omf dashboard um neue komponenten für produktkatalog, produktionsplanung und verbessertes shopfloor-layout. alle features sind vollständig implementiert, getestet und dokumentiert. ✨ neue features 📦 produktkatalog - yaml-basierte produktdefinitionen für rot, blau, weiss - html-template-system für konsistente visuelle darstellung - produktdetails - material, farbe, größe aus konfiguration - keine falschen bestand/verfügbar-informationen mehr 📋 produktionsplanung - fertigungsaufträge aus produktkatalog generieren - vertikale fertigungsablauf-darstellung in schönen boxen - hbw als erste box anlieferung , dps als letzte box abgabe - modul-icons für visuelle darstellung der fertigungsschritte - beschreibungen aus yaml-konfiguration 🗺️ shopfloor-layout verbesserungen - 4x3 grid-layout korrekt implementiert - modul-icons werden geladen">
                        <h3><a href="releases/dashboardv3.3.0-release-notes.md">OMF Dashboard v3.3.0 - Release Notes</a></h3>
                        <p>**Datum:** 4. Januar 2025</p>
                        <p><strong>📁 Pfad:</strong> releases/dashboardv3.3.0-release-notes.md</p>
                        <p><strong>📊 Größe:</strong> 6,956 Bytes | <strong>Wörter:</strong> 674</p>
                        <div class="keywords"><span class="keyword">release</span></div>
                    </div>

                    <div class="document" data-searchable="dashboard v3.3.1 release notes 🎉 release overview version: 3.3.1 release date: 2025-01-11 status: ✅ completed 🚀 major features 1. per-topic-buffer architecture ✨ new - topic-spezifische buffer für jede mqtt-subscription - automatische nachrichtensammlung in separaten buffers - effiziente verarbeitung ohne message-processor overhead - direkte buffer-zugriffe für optimale performance 2. mqtt-singleton pattern ✨ new - eine mqtt-client-instanz pro streamlit-session - zentraler zugriff über st.session_state "mqtt_client" - stabile verbindungen ohne verletzung des singleton-patterns - umgebungswechsel live/mock/replay ohne probleme 3. hybrid-architektur für publishing ✨ new - messagegenerator für payload-erstellung - session state für preview/edit-funktionalität - mqttgateway für finales publishing - workflowordermanager für orderid/orderupdateid verwaltung 🔧 technical improvements architecture migration - von message-processor zu per-topic-buffer: komplette architektur-migration - mqtt-sing">
                        <h3><a href="releases/dashboardv3.3.1-release-notes.md">Dashboard v3.3.1 Release Notes</a></h3>
                        <p>**Version:** 3.3.1</p>
                        <p><strong>📁 Pfad:</strong> releases/dashboardv3.3.1-release-notes.md</p>
                        <p><strong>📊 Größe:</strong> 10,827 Bytes | <strong>Wörter:</strong> 1029</p>
                        <div class="keywords"><span class="keyword">release</span></div>
                    </div>

                </div>
            </div>

            <div class="category">
                <h2>📂 root (15 Dokumente)</h2>
                <div class="documents">

                    <div class="document" data-searchable="changelog alle wichtigen änderungen an diesem projekt werden in dieser datei dokumentiert. das format basiert auf keep a changelog https://keepachangelog.com/de/1.0.0/ , und dieses projekt folgt semantic versioning https://semver.org/spec/v2.0.0.html . unreleased geplant - messagegenerator integration - replay station für dashboard-tests - template-analyse erweitern 3.3.1 - 2025-01-xx hinzugefügt - session manager: session analyse - timeline-visualisierung mit plotly - topic-filterung kategorie, sub-kategorie, friendly name, topic name - vorfilter-system für uninteressante topics - zeitfilter für timeline-analyse - settings-management für vorfilter-konfiguration - payload-analyse und message-details geändert - projekt-struktur aufgeräumt - dokumentation konsolidiert - import-standards vereinheitlicht behoben - importerror für omftopicmanager - vorfilter-loop-problem - struktur-validierung implementiert 3.3.0 - 2025-01-xx hinzugefügt - per-topic-buffer architektur - mqtt-singleton patte">
                        <h3><a href="CHANGELOG.md">Changelog</a></h3>
                        <p>Alle wichtigen Änderungen an diesem Projekt werden in dieser Datei dokumentiert.</p>
                        <p><strong>📁 Pfad:</strong> CHANGELOG.md</p>
                        <p><strong>📊 Größe:</strong> 2,638 Bytes | <strong>Wörter:</strong> 278</p>
                        <div class="keywords"></div>
                    </div>

                    <div class="document" data-searchable="omf modellfabrik - entwicklungsregeln > 📍 position: docs_orbis/development_rules.md > 🤖 cursor ai: siehe .cursorrules für ki-spezifische regeln 🎯 grundprinzipien 1. einfaches grundgerüst - keine überladung mit nicht notwendiger funktionalität - minimaler code für maximale übersichtlichkeit - schritt-für-schritt entwicklung - tests nach jeder änderung 2. sichere vorgehensweise - dashboard_migration_plan befolgen - häufige commits nach jedem erfolgreichen schritt - rollback bei fehlern möglich - immer funktionierenden stand haben 3. saubere architektur - trennung: aktive sourcen vs. helper-apps - aktive sourcen: src_orbis/omf/dashboard/ produktiv-dashboard - helper-apps: src_orbis/helper_apps/ , src_orbis/analysis_tools/ separate anwendungen - modulare komponenten in separaten dateien - klare import-pfade und abhängigkeiten - zweisprachigkeit: source-namen en, ui-namen de 4. import-standards zentrale entwicklungsregel - nur absolute imports verwenden: from src_orbis.omf.module import cla">
                        <h3><a href="DEVELOPMENT_RULES.md">**OMF Modellfabrik - Entwicklungsregeln**</a></h3>
                        <p>> **📍 Position:** `docs_orbis/DEVELOPMENT_RULES.md`</p>
                        <p><strong>📁 Pfad:</strong> DEVELOPMENT_RULES.md</p>
                        <p><strong>📊 Größe:</strong> 9,075 Bytes | <strong>Wörter:</strong> 903</p>
                        <div class="keywords"></div>
                    </div>

                    <div class="document" data-searchable="📋 import-standards guide - omf projekt 🎯 zentrale entwicklungsregel nur absolute imports verwenden - keine ausnahmen! ✅ korrekte imports dashboard-komponenten: python ✅ korrekt from src_orbis.omf.dashboard.components.dummy_component import show_dummy from src_orbis.omf.dashboard.assets.html_templates import get_template from src_orbis.omf.dashboard.omf_dashboard import main tools und utilities: python ✅ korrekt from src_orbis.omf.tools.sequence_executor import sequenceexecutor from src_orbis.omf.tools.sequence_ui import sequenceui from src_orbis.omf.tools.message_template_manager import get_message_template_manager from src_orbis.omf.tools.topic_manager import get_omf_topic_manager konfiguration: python ✅ korrekt from src_orbis.omf.config.config import config from src_orbis.omf.config.omf_config import config from src_orbis.omf.config.sequence_definitions.aiqs_sequence import aiqssequence helper-apps: python ✅ korrekt from src_orbis.helper_apps.replay_station.replay_station_dashboard i">
                        <h3><a href="IMPORT_STANDARDS_GUIDE.md">📋 Import-Standards Guide - OMF Projekt</a></h3>
                        <p>**NUR absolute Imports verwenden - KEINE Ausnahmen!**</p>
                        <p><strong>📁 Pfad:</strong> IMPORT_STANDARDS_GUIDE.md</p>
                        <p><strong>📊 Größe:</strong> 5,903 Bytes | <strong>Wörter:</strong> 553</p>
                        <div class="keywords"><span class="keyword">guide</span></div>
                    </div>

                    <div class="document" data-searchable="omf orbis modellfabrik dashboard architecture overview das omf dashboard ist eine moderne, modulare web-anwendung zur steuerung und überwachung der orbis modellfabrik. es basiert auf streamlit und implementiert die per-topic-buffer architektur mit mqtt-singleton pattern für optimale performance und einfachheit. architecture overview omf dashboard ├── frontend streamlit │ ├── main dashboard omf_dashboard.py │ └── components │ ├── overview components │ │ ├── overview_inventory.py lagerbestand │ │ ├── overview_customer_order.py kundenaufträge │ │ ├── overview_purchase_order.py rohmaterial-bestellungen │ │ └── overview_module_status.py modul-status per-topic-buffer │ ├── production order components │ │ ├── production_order_management.py auftragsverwaltung │ │ └── production_order_current.py laufende aufträge │ ├── steering components │ │ ├── steering_factory.py factory-steuerung hybrid-architektur │ │ ├── steering_sequence.py sequenz-steuerung │ │ └── steering_generic.py generic-steuerung ">
                        <h3><a href="OMF_ARCHITECTURE.md">OMF (ORBIS Modellfabrik) Dashboard Architecture</a></h3>
                        <p>Das OMF Dashboard ist eine moderne, modulare Web-Anwendung zur Steuerung und Überwachung der ORBIS Modellfabrik. Es basiert auf Streamlit und implementiert die **Per-Topic-Buffer Architektur** mit **M...</p>
                        <p><strong>📁 Pfad:</strong> OMF_ARCHITECTURE.md</p>
                        <p><strong>📊 Größe:</strong> 19,119 Bytes | <strong>Wörter:</strong> 1738</p>
                        <div class="keywords"></div>
                    </div>

                    <div class="document" data-searchable="orbis modellfabrik - projekt-übersicht 🎯 projektziel verständnis der funktionsweise der aps fischertechnik anwendung, um eine eigene anwendung zu bauen, die die steuerung der modellfabrik übernimmt. aps-fischertechnik system - reale miniatur-fabrik mit verschiedenen modulen - software zur steuerung der fabrik-prozesse - hauptprozesse: - wareneingang - produktion nach bestellung 🚀 geplante vorgehensweise phase 1: nachrichten-fluß aufnehmen ✅ - session-rekording der komponenten und module der aps-fabrik - status: abgeschlossen über python-script phase 2: session-analyse 🔄 - aktueller fokus: semantik und funktionsweise analysieren - ziel: erkenntnisse sammeln für steuerungs-entwicklung - tools: session manager helper app phase 3: steuerungs-entwicklung 📋 - ziel: anwendung für befehle/messages an fabrik-komponenten - tool: omf dashboard - funktion: senden von messages für aufgaben-erfüllung 🏗️ teilprojekte session manager helper app zweck: analyse und test der aufgenommenen sessions kompon">
                        <h3><a href="PROJECT_OVERVIEW.md">ORBIS Modellfabrik - Projekt-Übersicht</a></h3>
                        <p>Verständnis der Funktionsweise der APS Fischertechnik Anwendung, um eine eigene Anwendung zu bauen, die die Steuerung der Modellfabrik übernimmt.</p>
                        <p><strong>📁 Pfad:</strong> PROJECT_OVERVIEW.md</p>
                        <p><strong>📊 Größe:</strong> 3,380 Bytes | <strong>Wörter:</strong> 360</p>
                        <div class="keywords"></div>
                    </div>

                    <div class="document" data-searchable="orbis modellfabrik - documentation this directory contains comprehensive documentation for the orbis modellfabrik system, based on the fischertechnik agile production simulation 24v. 📁 folder structure original fischertechnik content - data/ - original data files - plc-programs/ - original plc programs - txt4.0-programs/ - original txt4.0 programs - node-red/ - original node-red flows - doc/ - original documentation orbis customizations - docs_orbis/ - orbis documentation this folder - src_orbis/ - orbis source code - tests_orbis/ - orbis tests 📚 documentation structure project overview ./project_overview.md - system overview - complete project analysis and architecture - core technology - mqtt-based communication system - orbis components - central configuration managers and dashboard - current status - modern yaml-based architecture development rules ./development_rules.md - import standards - absolute imports only - code quality - black, ruff, pre-commit hooks - test standards - bra">
                        <h3><a href="README.md">Orbis Modellfabrik - Documentation</a></h3>
                        <p>This directory contains comprehensive documentation for the Orbis Modellfabrik system, based on the Fischertechnik Agile Production Simulation 24V.</p>
                        <p><strong>📁 Pfad:</strong> README.md</p>
                        <p><strong>📊 Größe:</strong> 6,604 Bytes | <strong>Wörter:</strong> 799</p>
                        <div class="keywords"><span class="keyword">overview</span></div>
                    </div>

                    <div class="document" data-searchable="🔐 orbis modellfabrik - credentials & access this document contains default login credentials and access information for the orbis modellfabrik system components. ⚠️ security notice important : these are default credentials. for production use, always change default passwords and use secure authentication methods. 🏭 aps modellfabrik components ccu central control unit - raspberry pi - komponente : ccu central control unit - hardware : raspberry pi - ip address : 192.168.0.100 - web interface : http://192.168.0.100/de/aps/ - ssh access : - username: ff22 - default password: ff22+ - ssh port: 22 - status : ✅ web-interface funktioniert! - ssh zu testen - beschreibung : zentrale steuereinheit der aps-modellfabrik mqtt broker mosquitto - komponente : mqtt broker - software : mosquitto - host : 192.168.0.100 - port : 1883 - authentication : required currently blocking connections - default login : default / default - status : ✅ funktioniert! - verbindung erfolgreich - beschreibung : mqtt-brok">
                        <h3><a href="credentials.md">🔐 Orbis Modellfabrik - Credentials & Access</a></h3>
                        <p>This document contains default login credentials and access information for the Orbis Modellfabrik system components.</p>
                        <p><strong>📁 Pfad:</strong> credentials.md</p>
                        <p><strong>📊 Größe:</strong> 6,823 Bytes | <strong>Wörter:</strong> 915</p>
                        <div class="keywords"></div>
                    </div>

                    <div class="document" data-searchable="factory steering regeln übersicht dieses dokument beschreibt die aktuellen regeln für die factory_steering.py komponente im omf dashboard. diese regeln stellen sicher, dass alle mqtt-nachrichten den korrekten standards entsprechen. wichtige prinzipien 1. historische tests bleiben unverändert - unit-tests aus commit 807c29a sind historische referenzen - sie dokumentieren, was in diesem commit funktioniert hat - sie werden nicht angepasst oder geändert 2. neue tests für aktuelle regeln - neue unit-tests validieren die aktuellen implementierungen - sie testen topic + message + regeln in kombination - sie stellen sicher, dass die regeln eingehalten werden mqtt topic regeln modul-topics alle modul-befehle verwenden das folgende topic-pattern: module/v1/ff/{serial_number}/order spezifische topics: - drill : module/v1/ff/svr4h76449/order - mill : module/v1/ff/svr3qa2098/order - aiqs : module/v1/ff/svr4h76530/order fts-topics fts-befehle verwenden: fts/v1/ff/5io4/order ccu-topics factory-reset">
                        <h3><a href="factory_steering_rules.md">Factory Steering Regeln</a></h3>
                        <p>Dieses Dokument beschreibt die aktuellen Regeln für die `factory_steering.py` Komponente im OMF Dashboard. Diese Regeln stellen sicher, dass alle MQTT-Nachrichten den korrekten Standards entsprechen.</p>
                        <p><strong>📁 Pfad:</strong> factory_steering_rules.md</p>
                        <p><strong>📊 Größe:</strong> 5,415 Bytes | <strong>Wörter:</strong> 590</p>
                        <div class="keywords"></div>
                    </div>

                    <div class="document" data-searchable="fts navigation examples 🗺️ fts grid-layout 4x3 raster : empty mill aiqs empty | | hbw ------ 1 ------- 2 ------- dps | | drill ----- 3 ------- 4 ------- chrg0 📊 grid-details: module-positionen 6 : - hbw: links unten - drill: links unten zweite reihe - mill: oben mitte - aiqs: oben rechts - dps: rechts mitte - chrg0: rechts unten kreuzungspunkte/intersections 4 : - 1: mitte links hbw ↔ mill - 2: mitte rechts mill ↔ aiqs ↔ dps - 3: unten links drill ↔ hbw - 4: unten rechts drill ↔ chrg0 ↔ dps 🎯 navigation-logik: - navigation: position → position - kreuzungspunkte: links, rechts, pass-through je nach ziel - grid-basierte navigation mit 10 positionen 6 module + 4 intersections 🚛 funktionierende fts-navigation: dps → hbw topic: fts/v1/ff/5io4/order payload: json { "timestamp": "2025-01-19t10:00:00.000z", "orderid": "test-navigation-dps-to-hbw-wareneingang-001", "orderupdateid": 0, "nodes": { "id": "svr4h73275", "linkededges": "svr4h73275-2" }, { "id": "2", "linkededges": "svr4h73275-2", "2-">
                        <h3><a href="fts-navigation-examples.md">fts-navigation-examples</a></h3>
                        <p>[EMPTY]    [MILL]    [AIQS]    [EMPTY]</p>
                        <p><strong>📁 Pfad:</strong> fts-navigation-examples.md</p>
                        <p><strong>📊 Größe:</strong> 8,510 Bytes | <strong>Wörter:</strong> 888</p>
                        <div class="keywords"></div>
                    </div>

                    <div class="document" data-searchable="per-topic-buffer pattern übersicht das per-topic-buffer pattern ist die aktuelle architektur für mqtt-nachrichtenverarbeitung im omf dashboard. es bietet eine saubere, effiziente lösung für die verarbeitung von mqtt-nachrichten. architektur-prinzipien 1. mqtt-singleton pattern - eine mqtt-client-instanz pro streamlit-session - zentraler zugriff über st.session_state "mqtt_client" - keine verletzung des singleton-patterns durch direkte client-aufrufe 2. per-topic-buffer system - topic-spezifische buffer für jede mqtt-subscription - automatische nachrichtensammlung in separaten buffers - effiziente verarbeitung ohne message-processor overhead 3. hybrid-architektur für publishing - messagegenerator für payload-erstellung - session state für preview/edit-funktionalität - mqttgateway für finales publishing implementierung subscription pattern python 1. topics subscriben client.subscribe_many "module/v1/ff/+/state", "module/v1/ff/+/connection", "ccu/pairing/state", "module/v1/ff/+/factsheet"">
                        <h3><a href="per-topic-buffer-pattern.md">Per-Topic-Buffer Pattern</a></h3>
                        <p>Das **Per-Topic-Buffer Pattern** ist die aktuelle Architektur für MQTT-Nachrichtenverarbeitung im OMF Dashboard. Es bietet eine saubere, effiziente Lösung für die Verarbeitung von MQTT-Nachrichten.</p>
                        <p><strong>📁 Pfad:</strong> per-topic-buffer-pattern.md</p>
                        <p><strong>📊 Größe:</strong> 6,110 Bytes | <strong>Wörter:</strong> 540</p>
                        <div class="keywords"></div>
                    </div>

                    <div class="document" data-searchable="voraussetzungen für mqtt mock system dieser guide listet alle notwendigen voraussetzungen für das testen des mqtt mocking systems auf. 🔧 systemvoraussetzungen 1. python version 3.7 oder höher prüfung: bash python3 --version installation falls nicht vorhanden : bash macos brew install python3 ubuntu/debian sudo apt update sudo apt install python3 python3-pip windows download von python.org 2. mqtt broker mosquitto installation: bash macos brew install mosquitto ubuntu/debian sudo apt install mosquitto mosquitto-clients windows download von mosquitto.org alternative: docker bash docker run -d --name mqtt-broker \ -p 1883:1883 \ -p 9001:9001 \ eclipse-mosquitto:latest 3. python dependencies automatische installation: bash alle dependencies installieren pip install -r requirements.txt oder nur mqtt pip install paho-mqtt>=1.6.1 manuelle installation: bash pip install paho-mqtt pip install numpy pip install pandas pip install matplotlib pip install seaborn 🚀 schnelltest der voraussetzungen a">
                        <h3><a href="prerequisites.md">Voraussetzungen für MQTT Mock System</a></h3>
                        <p>Dieser Guide listet alle notwendigen Voraussetzungen für das Testen des MQTT Mocking Systems auf.</p>
                        <p><strong>📁 Pfad:</strong> prerequisites.md</p>
                        <p><strong>📊 Größe:</strong> 4,484 Bytes | <strong>Wörter:</strong> 538</p>
                        <div class="keywords"></div>
                    </div>

                    <div class="document" data-searchable="omf streamlit dashboard anforderungen 1 ziel und nutzen - nachbau der applikation aps von fischertechnuk - echtzeit-monitoring aller module und deren status - nachrichtenverwaltung mit persistierung und historie - steuerung der fabrik-module, komponenten und prozesse durch versenden von mqtt-messages, so wie es die aps applikation macht. - messagetemplate syntaktische und semantische beschreibung der nachrichten der aps, sowie kopplung zu den mqtt-topics, damit eine steuerung möglich ist. - replay-station abspielen von zuvor aufgenommenn sessions nachrichten-auustausch zu testzwecken, dazu kann das dashboard wahlweise die verbindung zu aps-mqtt-broker oder zu einem lokalen broker aufgebaut werden, der über ein separates dashboard, die aufgenommenen nachrichten abspielen=senden kann. 2 architektur kurz - omfmqttclient als zentraler mqtt-client singleton-pattern - @st.cache_resource für persistente services über streamlit-reruns - einzelner mqtt-client für subscribe und publish - thread-">
                        <h3><a href="requirements_dashboard.md">OMF Streamlit Dashboard Anforderungen</a></h3>
                        <p>- **Nachbau der Applikation APS von Fischertechnuk**</p>
                        <p><strong>📁 Pfad:</strong> requirements_dashboard.md</p>
                        <p><strong>📊 Größe:</strong> 15,476 Bytes | <strong>Wörter:</strong> 1750</p>
                        <div class="keywords"></div>
                    </div>

                    <div class="document" data-searchable="anforderungen: sequenzielle steuerungsbefehle in logischer klammer mit ui-unterstützung finale version problemstellung die orbis modellfabrik benötigt ein system zur sequenziellen ausführung von steuerungsbefehlen mit ui-unterstützung in logischer klammer . aktuell werden module mill, drill, aiqs manuell schritt-für-schritt gesteuert, was fehleranfällig und zeitaufwendig ist. die steuerungsbefehle werden in form von mqtt-messages an die module abgesendet. --- funktionale anforderungen 1. logische klammer für sequenz-ausführung - geschlossene einheit : eine sequenz läuft als logische einheit z.b. pick → process → drop - abbruch-fähigkeit : bei bedarf kann die sequenz abgebrochen werden - konsistente ids : orderid bleibt konstant, orderupdateid wird pro schritt inkrementiert - status-tracking : vollständige nachverfolgung des sequenz-status 2. ui-unterstützung für sequenzen - sequenz-fenster : öffnet sich bei sequenz-start und bleibt bis ende offen - visuelle sequenz-darstellung : schrit">
                        <h3><a href="requirements_sequence_control.md">**Anforderungen: Sequenzielle Steuerungsbefehle in logischer Klammer mit UI-Unterstützung (Finale Version)**</a></h3>
                        <p>Die ORBIS Modellfabrik benötigt ein System zur **sequenziellen Ausführung von Steuerungsbefehlen** mit **UI-Unterstützung in logischer Klammer**. Aktuell werden Module (MILL, DRILL, AIQS) manuell Schr...</p>
                        <p><strong>📁 Pfad:</strong> requirements_sequence_control.md</p>
                        <p><strong>📊 Größe:</strong> 7,695 Bytes | <strong>Wörter:</strong> 874</p>
                        <div class="keywords"></div>
                    </div>

                    <div class="document" data-searchable="sequenz-steuerung implementation - januar 2025 🎯 übersicht die sequenz-steuerung wurde erfolgreich implementiert und in das omf dashboard integriert. sie ermöglicht die automatisierte ausführung von vordefinierten sequenzen mit korrekten mqtt-nachrichten, die identisch mit der factory-steuerung sind. ✅ implementierte features 1. sequenz-definitionen - drill-sequenz: pick → drill → drop - mill-sequenz: pick → mill → drop - aiqs-sequenz: pick → check_quality → drop 2. automatische sequenz-ausführung - automatische progression: nächste schritte werden automatisch nach 5 sekunden ausgeführt - wait-steps: konfigurierbare wartezeiten zwischen schritten standard: 5 sekunden - status-tracking: detaillierte verfolgung des sequenz-fortschritts 3. mqtt-integration - identische nachrichten-struktur: sequenz-nachrichten sind identisch mit factory-steuerung - korrekte payload-formatierung: json { "serialnumber": "svr4h76530", "action": { "id": "uuid-here", "command": "pick", "metadata": { "priority"">
                        <h3><a href="sequence-control-implementation-2025-01.md">Sequenz-Steuerung Implementation - Januar 2025</a></h3>
                        <p>Die Sequenz-Steuerung wurde erfolgreich implementiert und in das OMF Dashboard integriert. Sie ermöglicht die automatisierte Ausführung von vordefinierten Sequenzen mit korrekten MQTT-Nachrichten, die...</p>
                        <p><strong>📁 Pfad:</strong> sequence-control-implementation-2025-01.md</p>
                        <p><strong>📊 Größe:</strong> 5,664 Bytes | <strong>Wörter:</strong> 544</p>
                        <div class="keywords"></div>
                    </div>

                    <div class="document" data-searchable="singleton-pattern compliance ✅ aktuell korrekt umgesetzt 1. einziger client pro session - implementiert: ensure_dashboard_client in omf_dashboard.py - speicherung: st.session_state "mqtt_client" - dokumentation: "liefert genau einen mqtt-client pro streamlit-session" 2. idempotente subscriptions - implementiert: subscribe_many verhindert doppelte subscriptions - code: new_ones = f for f in filters if f not in self._subscribed 3. komponenten-parameter-pattern - implementiert: mqttgateway wird an komponenten übergeben - keine direkten client-erstellungen in komponenten 4. umgebungswechsel - implementiert: reconnect statt neuer client-instanz - fallback: nur bei fehlern wird neuer client erstellt ⚠️ noch zu implementieren 1. message callback idempotenz problem: doppelte callbacks möglich python aktuell: for f in new_ones: self.client.subscribe f, qos=qos self._subscribed.add f empfohlen: for f in new_ones: self.client.subscribe f, qos=qos self.client.message_callback_add f, self._dispatch">
                        <h3><a href="singleton-pattern-compliance.md">Singleton-Pattern Compliance</a></h3>
                        <p>- **Implementiert:** `ensure_dashboard_client()` in `omf_dashboard.py`</p>
                        <p><strong>📁 Pfad:</strong> singleton-pattern-compliance.md</p>
                        <p><strong>📊 Größe:</strong> 3,235 Bytes | <strong>Wörter:</strong> 359</p>
                        <div class="keywords"></div>
                    </div>

                </div>
            </div>

        </div>
    </div>
    
    <script>
        function searchDocuments() {
            const searchTerm = document.getElementById('searchInput').value.toLowerCase();
            const documents = document.querySelectorAll('.document');
            
            documents.forEach(doc => {
                const searchableContent = doc.getAttribute('data-searchable');
                if (searchableContent.includes(searchTerm) || searchTerm === '') {
                    doc.style.display = 'block';
                } else {
                    doc.style.display = 'none';
                }
            });
        }
    </script>
</body>
</html>
