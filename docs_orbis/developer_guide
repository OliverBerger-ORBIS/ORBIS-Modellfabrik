# ORBIS Modellfabrik ‚Äì Developer Guide

Version: 0.1 (Draft)  
Last updated: 2025-09-14  
Author: OMF Development Team  

---

## üìë Table of Contents
- [1. Introduction](#1-introduction)
- [2. Project Setup](#2-project-setup)
- [3. Repository Structure](#3-repository-structure)
- [4. Configuration Files](#4-configuration-files)
  - [4.1 Module Config](#41-module-config)
  - [4.2 NFC Config](#42-nfc-config)
  - [4.3 Topic Config](#43-topic-config)
  - [4.4 Message Templates](#44-message-templates)
  - [4.5 Registry & Schemas](#45-registry--schemas)
- [5. Development Workflow](#5-development-workflow)
  - [5.1 Branching & Git Strategy](#51-branching--git-strategy)
  - [5.2 CI Tools & Validation](#52-ci-tools--validation)
  - [5.3 Session Recording & Replay](#53-session-recording--replay)
- [6. Testing Strategy](#6-testing-strategy)
- [7. Documentation Strategy](#7-documentation-strategy)
- [8. Sprint Notes](#8-sprint-notes)
- [9. Glossary](#9-glossary)

---

## 1. Introduction
Kurze Einf√ºhrung in Zweck & Ziele:
- OMF Dashboard & Tools f√ºr APS/Modellfabrik  
- Fokus: MQTT-basiertes Shopfloor Processing (DSP)  
- Zielgruppe: Entwickler & Integratoren  

---

## 2. Project Setup
- Voraussetzungen: Python, MQTT-Broker, Node-RED  
- Installation:  
  ```bash
  make install
  make validate
  ```

### 2.1 Development Environment
- **Python**: 3.8+ mit virtual environment
- **MQTT Broker**: Mosquitto oder √§hnlich
- **Node-RED**: F√ºr MQTT-OPC-UA Gateway
- **Streamlit**: F√ºr Dashboard-Entwicklung

### 2.2 Critical Development Rules
- **NUR absolute Pfade:** `/Users/oliver/Projects/ORBIS-Modellfabrik/path/to/file`
- **NUR absolute Imports:** `from src_orbis.omf.module import Class`
- **KEINE relativen Pfade/Imports** ‚ùå
- **KEINE sys.path.append Hacks** ‚ùå

## 3. Repository Structure

Aktuelle Struktur (Stand Sprint A):

src_orbis/omf/config/      # Zentrale Configs & Templates
registry/                  # Registries & JSON Schemas
data/observations/         # Session Logs & Replay-Daten
docs_orbis/                # Projektdokumentation



## 4. Configuration Files
## 4.1 Module Config

module_config.yml ‚Üí Zuordnung von Modulen (HBW, DRILL, MILL ‚Ä¶)

Enth√§lt: IDs, Typen, IPs, Befehle

## 4.2 NFC Config

nfc_config.yml ‚Üí Mapping NFC-Codes ‚Üî Workpieces

## 4.3 Topic Config

topic_config.yml ‚Üí MQTT-Topic-Struktur

## 4.4 Message Templates

message_templates/* ‚Üí Struktur & Beispiele f√ºr alle Nachrichten

Aufgeteilt nach CCU, Module, FTS, Node-RED, TXT

## 4.5 Registry & Schemas

JSON-Schemas validieren Konsistenz

Makefile Targets:

make validate-mapping
make check-mapping-collisions

## 5. Development Workflow

### 5.1 Critical Development Rules

#### üö® KEINE COMMITS VOR TESTS
- **NIEMALS** Commits durchf√ºhren bevor alle Implementierungen vollst√§ndig getestet wurden
- Jede neue Funktionalit√§t muss erst funktional getestet werden:
  - Dashboard startet ohne Fehler
  - Features funktionieren wie erwartet
  - Keine Runtime-Fehler
  - UI ist bedienbar
- **Tests haben absolute Priorit√§t vor Commits**

#### üîÑ TEST-FIRST DEVELOPMENT
- Implementierung ‚Üí Test ‚Üí Fix ‚Üí Test ‚Üí Commit
- Nur bei 100% funktionierenden Features committen
- Bei Fehlern: Fix implementieren, erneut testen

### 5.2 Import Standards

#### ‚úÖ KORREKTE Imports
```python
# Dashboard-Komponenten
from src_orbis.omf.dashboard.components.dummy_component import show_dummy
from src_orbis.omf.dashboard.assets.html_templates import get_template

# Tools und Utilities
from src_orbis.omf.tools.sequence_executor import SequenceExecutor
from src_orbis.omf.tools.message_template_manager import get_message_template_manager

# Konfiguration
from src_orbis.omf.config.config import config
from src_orbis.omf.config.sequence_definitions.aiqs_sequence import AIQSSequence

# Helper-Apps
from src_orbis.helper_apps.replay_station.replay_station_dashboard import main
```

#### ‚ùå VERBOTENE Imports
```python
# Relative Imports
from ..module import Class
from .component import show_component

# Lokale Imports
from module import Class
from component import show_component

# sys.path.append Hacks
import sys
sys.path.append(os.path.join(os.path.dirname(__file__), "..", ".."))
```

### 5.3 Branching & Git Strategy
- **main** = stabil
- **feature/*** = Entwicklung
- **sprint/*** = gr√∂√üere Umbauten

### 5.4 CI Tools & Validation
- **Schema Validation**: `make validate-mapping`
- **Mapping Collision Detection**: `make check-mapping-collisions`
- **Template Resolver**: Automatische Template-Aufl√∂sung
- **Import-Check**: Automatische √úberpr√ºfung der Import-Standards

### 5.5 Session Recording & Replay
- **Recorder**: speichert Nachrichtenstr√∂me (SQLite, Logs)
- **Replay**: befeuert OMF-Dashboard mit gespeicherten Sessions
- **Analyse**: Graphen & Template-Bibliothek

### 5.6 Dashboard Component Rules

#### Wrapper-Komponenten (Haupt-Tabs)
```python
def show_steering():
    """Hauptfunktion f√ºr die Steuerung mit Untertabs"""
    st.header("üéÆ Steuerung")
    st.markdown("Alle Steuerungsfunktionen der ORBIS Modellfabrik")
    
    # Untertabs f√ºr verschiedene Steuerungsarten
    steering_tab1, steering_tab2, steering_tab3 = st.tabs(
        ["üè≠ Factory-Steuerung", "üîß Generische Steuerung", "üéØ Sequenz-Steuerung"]
    )
```

**Regeln:**
- **Funktionsname:** `show_<component_name>()`
- **Header:** `st.header()` mit Icon + Name
- **Tabs:** `st.tabs()` f√ºr Unterkomponenten
- **MQTT-Client:** Immer pr√ºfen und Fehlerbehandlung
- **Gateway:** `MqttGateway(mqtt_client)` verwenden

#### UI-Refresh-Regeln
```python
# ‚úÖ RICHTIG - zentraler Refresh
from src_orbis.omf.dashboard.utils.ui_refresh import request_refresh

def show_my_component():
    if some_condition:
        request_refresh()  # L√∂st zentralen Refresh aus
```

**Verboten:** `st.rerun()` in Komponenten (f√ºhrt zu MQTT-Subscription-Verlust)

### 5.7 MQTT-Subscription Pattern

#### Per-Topic-Buffer Pattern (Standard)
```python
# ‚úÖ RICHTIG - Spezifische Topics f√ºr Komponenten
mqtt_client.subscribe_many([
    "module/v1/ff/+/state",
    "module/v1/ff/+/connection",
    "ccu/state"
], qos=1)

# Nachrichten aus Per-Topic-Buffer holen
state_messages = list(mqtt_client.get_buffer("module/v1/ff/+/state"))
connection_messages = list(mqtt_client.get_buffer("module/v1/ff/+/connection"))
```

**Vorteile:**
- **Performant:** Nur relevante Nachrichten
- **Skalierbar:** Pro Komponente spezifische Topics
- **Ressourcenschonend:** Keine globalen Subscriptions

#### Message Center Ausnahme
```python
# ‚úÖ ERLAUBT - Nur im Message Center
mqtt_client.subscribe("#", qos=1)  # Wildcard-Subscription
all_messages = list(mqtt_client._history)  # Globale History
```

**Warum Ausnahme:**
- **Message Center** ben√∂tigt **alle Nachrichten**
- **√úbersichtsfunktion** f√ºr Debugging und Monitoring
- **Validierungsregel** erlaubt `subscribe("#")` nur in `message_center.py`

**Regeln:**
- **Standard:** Per-Topic-Buffer Pattern f√ºr alle Komponenten
- **Ausnahme:** Wildcard-Subscription nur im Message Center
- **Verboten:** `subscribe("#")` in anderen Komponenten

### 5.8 Logging System

#### Thread-sicheres Logging
```python
def _init_logging_once():
    """Initialisiert Logging einmal pro Streamlit-Session"""
    if st.session_state.get("_log_init"):
        return
    
    # Queue-basiertes Logging f√ºr Thread-Sicherheit
    root, listener = configure_logging(level=20, console_pretty=True)
    st.session_state["_log_listener"] = listener
    st.session_state["_log_init"] = True
```

**Regeln:**
- **Einmalige Initialisierung:** `_init_logging_once()`
- **Thread-sicher:** Queue-basiert f√ºr MQTT-Callbacks
- **Keine UI-Operationen** in MQTT-Callbacks

## 6. Testing Strategy

### 6.1 Test-Kategorien (KRITISCH)
- **Unit-Tests**: Automatische Tests f√ºr einzelne Funktionen
- **Integration-Tests**: Tests f√ºr Komponenten-Interaktion
- **UI-Tests**: Manuelle Tests der Benutzeroberfl√§che (KRITISCH)
  - Session Manager: Graph-Visualisierung, alle Tabs funktional
  - OMF-Dashboard: Module Control, alle Komponenten laden
  - Logging-System: Keine Spam-Logs, saubere Ausgabe
- **UI-Tests werden vom Benutzer durchgef√ºhrt und Ergebnisse mitgeteilt**

### 6.2 Test-Strategien
- **Replay-Tests**: Sessions gegen Dashboard
- **Simulation**: k√ºnstliche Orders an Module
- **CI-Validation**: Schemas & Templates

### 6.3 Test-Checkliste
- [ ] **Unit-Tests**: Alle Funktionen getestet
- [ ] **Integration-Tests**: Komponenten-Interaktion funktioniert
- [ ] **UI-Tests**: Benutzeroberfl√§che vollst√§ndig bedienbar
- [ ] **Performance-Tests**: Keine Memory-Leaks oder Performance-Probleme

### 6.4 Tools und Automatisierung

#### Import-Check Scripts
```bash
# Alle relativen Imports finden
grep -r "from \.\." src_orbis/

# Alle sys.path.append finden
grep -r "sys.path.append" src_orbis/

# Alle lokalen Imports finden
grep -r "from [a-zA-Z_][a-zA-Z0-9_]* import" src_orbis/ | grep -v "src_orbis"
```

#### Pre-commit Hooks
```yaml
# .pre-commit-config.yaml
- repo: local
  hooks:
    - id: check-imports
      name: Check Import Standards
      entry: python scripts/check_imports.py
      language: system
      files: \.py$
```

## 7. Documentation Strategy

docs_orbis/ als zentraler Doku-Ort

developer_guide.md = Einstiegspunkt

sprints/ = Sprint-Dokumentation (√Ñnderungshistorie)

Erg√§nzung: registry_reference.md f√ºr Schemas

## 8. Sprint Notes

Sprint A: Registry-Ansatz eingef√ºhrt, CI-Tools integriert

Sprint B: Aufteilung von module/state.yml geplant

Details siehe docs_orbis/sprints/
.

## 9. Glossary

APS: Agile Production System (Fischertechnik)

OMF: ORBIS Modellfabrik Tools

CCU: Central Control Unit

FTS: Fahrerloses Transportsystem

HBW: Hochregallager

DPS: Delivery & Pickup Station

AIQS: Automated Inspection & Quality Station
