import { CcuTopic } from '../../../../common/protocol';
import { FactoryLayout, FactoryNode, RoadDirection } from '../../../../common/protocol/ccu';
import { Module, ModuleType } from '../../../../common/protocol/module';
import config from '../../config';
import { readJsonFile, writeJsonFile } from '../../helpers';
import { getMqttClient } from '../../mqtt/mqtt';
import { publishPairingState } from '../pairing';
import { PairingStates } from '../pairing/pairing-states';
import { DEFAULT_LAYOUT } from './default_reset/default_layout';

/**
 * This node represents an actual module in the factory.
 * Therefore, it has a specific serial number assigned to it, namely the serial number of the module.
 *
 *
 */
export interface ModuleNode extends FactoryNode {
  /**
   * The actual module which is placed on this node.
   */
  module: Module;
}

/**
 * A factory road represents a path between two Nodes. It has a specific length which
 * is used to calculate the time it takes to drive this road (by the FTS).
 * Although it can be driven both ways by an FTS, it is represented as a directed edge.
 * This is needed to have a specific representation of the factory layout (e.g. which module
 * is above which) in order to calculate the rotation of the FTS.
 *
 * TODO: FITEFF22-349 Add functions for default layout: load, replace placeholder
 */
export interface FactoryRoad {
  /**
   * The length of the road in millimeters. This needs to represent the actual length of the road,
   * otherwise navigation won't work.
   */
  length: number;
  /**
   * The direction in which the road is pointing.
   */
  direction: RoadDirection;
  /** The starting point of the road */
  from: ModuleNode | FactoryNode;
  /** The end point of the road */
  to: ModuleNode | FactoryNode;
}

export interface FactoryGraph {
  nodes: Array<ModuleNode | FactoryNode>;
  edges: Array<FactoryRoad>;
}

export interface FactoryNodeBlocker {
  nodeId: string;
  ftsSerialNumber: string;
  /** The blocked node will be driven to after this node. This node can be unblocked when the FTS has reached the node of this FactoryNodeBlocker instance  */
  afterNodeId?: string;
}

/**
 * Responsible for managing the layout of the future factory.
 * This includes persisting changes to the layout and providing a graph representation of the layout.
 * {@link NavigatorService} uses this graph to determine the path between two modules which can be used to
 * drive the FTS.
 */
export class FactoryLayoutService {
  private static _graph: FactoryGraph | undefined;
  private static layout: FactoryLayout | undefined;
  private static layout_file?: string;
  private static blocked_nodes: Map<string, FactoryNodeBlocker> | undefined;

  /**
   * This method is supposed to be called in the initial startup routine of the CCU before
   * any orders are processed or generated by the CCU (i.e. before the MQTT connection is established)
   *
   * @param [filename] Filename for persistent graph storage, use memory when undefined.
   */
  public static async initialize(filename?: string) {
    console.debug('Initialize the Factory Layout Service');
    if (this._graph) {
      throw new Error('FactoryLayout already initialized');
    }
    console.log('Factory Graph initialized');
    this.blocked_nodes = new Map<string, FactoryNodeBlocker>();
    FactoryLayoutService.graph = FactoryLayoutService.getEmptyGraph();
    this.layout = FactoryLayoutService.getEmptyLayout();
    if (filename) {
      console.debug(`PERSISTENCE: Loading and saving layout from ${filename}`);
      this.layout_file = filename;
      await this.reloadLayout();
    } else {
      await this.loadDefaultLayout();
    }
    console.debug('Factory Layout Service ready');
  }

  public static getEmptyGraph(): FactoryGraph {
    return {
      nodes: [],
      edges: [],
    };
  }

  public static getEmptyLayout(): FactoryLayout {
    return {
      modules: [],
      intersections: [],
      roads: [],
    };
  }
  public static async loadDefaultLayout(): Promise<void> {
    const layout = JSON.parse(JSON.stringify(DEFAULT_LAYOUT)) as FactoryLayout;
    this.setLayout(layout);
    await this.publishLayout();
  }

  public static async resetToDefaultLayout() {
    await this.loadDefaultLayout();
    await this.saveLayout();
  }

  public static logGraph() {
    FactoryLayoutService.checkIsInitialized();
    console.debug(JSON.stringify(FactoryLayoutService.graph, null, 2));
  }

  /**
   * TODO: Maybe we want to extend this to a new interface "plate" which represents an actual ground plate of the ff
   * Based on the input modules, intersections and edges, this method generates a graph representation of the factory layout.
   *
   * This implementation automatically inserts the inverse roads in the graph.
   *
   * @param modules
   * @param intersections
   * @param edges
   */
  public static generateGraph(modules: Array<Module>, intersections: Array<FactoryNode>, edges: Array<FactoryRoad>): FactoryGraph {
    const generatedGraph: FactoryGraph = FactoryLayoutService.getEmptyGraph();
    modules.forEach(module => {
      const moduleNode: ModuleNode = FactoryLayoutService.getModuleNode(module);
      if (FactoryLayoutService.isNodeDuplicate(moduleNode, generatedGraph.nodes)) {
        throw Error(`Node ${JSON.stringify(moduleNode)} already exists`);
      }
      console.log('Adding module node', moduleNode);
      generatedGraph.nodes.push(moduleNode);
    });

    intersections.forEach(intersection => {
      if (FactoryLayoutService.isNodeDuplicate(intersection, generatedGraph.nodes)) {
        throw Error(`Node ${JSON.stringify(intersection)} already exists`);
      }
      console.log('Adding intersection', intersection);
      generatedGraph.nodes.push(intersection);
    });

    edges.forEach(edge => {
      console.log('Checking duplicate', edge);
      if (FactoryLayoutService.isEdgeDuplicate(edge, generatedGraph.edges)) {
        throw Error(`Edge from ${JSON.stringify(edge.from)} to ${JSON.stringify(edge.to)} already exists`);
      }
      console.log('Adding edge', edge);
      generatedGraph.edges.push(edge);
    });

    // Add inverse edges
    console.log('ADDING INVERSE EDGES');
    const inverseEdges: FactoryRoad[] = [];
    generatedGraph.edges.forEach(edge => {
      // Add inverse edge
      const inverseEdge = FactoryLayoutService.getInverseEdge(edge);
      console.log('Checking inverse duplicate', inverseEdge);
      if (FactoryLayoutService.isEdgeDuplicate(inverseEdge, generatedGraph.edges)) {
        throw Error(`Inverse edge from ${JSON.stringify(inverseEdge.from)} to ${JSON.stringify(inverseEdge.to)} already exists`);
      }
      console.log('Adding inverse edge', inverseEdge);
      inverseEdges.push(inverseEdge);
    });
    generatedGraph.edges.push(...inverseEdges);

    return generatedGraph;
  }

  /**
   * Load a factory layout from modules, intersections and edges in a json file
   *
   * @param filepath The location of the layout file
   * @return the layout or null if it cannot be loaded
   */
  public static async loadLayoutFromJsonFile(filepath: string): Promise<FactoryLayout | null> {
    try {
      const layout = await readJsonFile<FactoryLayout>(filepath);
      if ('roads' in layout && 'modules' in layout && 'intersections' in layout) {
        return layout;
      } else {
        console.error('Invalid json object for factory layout.');
      }
    } catch (e) {
      console.error('Error while loading json layout:', e);
    }
    return null;
  }

  /**
   * Generate the factory graph based on the layout object
   *
   * This implementation automatically inserts the inverse roads in the graph.
   *
   * @param {FactoryLayout} layout The flat factory layout
   */
  public static generateGraphFromJsonLayout(layout: FactoryLayout): FactoryGraph {
    const getNodeForId = (id: string): ModuleNode | FactoryNode | undefined => {
      const intersection = layout.intersections.find(node => node.id === id);
      if (intersection) {
        return intersection;
      }
      const module = layout.modules.find(mod => mod.serialNumber === id);
      if (module) {
        return FactoryLayoutService.getModuleNode(module);
      }
      return undefined;
    };

    const roads: FactoryRoad[] = layout.roads
      .map(road => {
        return {
          direction: road.direction,
          length: road.length,
          from: getNodeForId(road.from),
          to: getNodeForId(road.to),
        };
      })
      .filter((road): road is FactoryRoad => !!road.from && !!road.to);
    return FactoryLayoutService.generateGraph(layout.modules, layout.intersections, roads);
  }

  /**
   * Duplicates a directed edge to have its inverse:
   * - start and target node are switched
   * - the direction is inversed (e.g. NORTH -> SOUTH)
   * Used to generate all inverse edges to reduce setup boilderplating
   * This method assumes, all edges are directed but have an inverse edge for the way backwards
   * @param edge The edge to inverse
   */
  public static getInverseEdge(edge: FactoryRoad): FactoryRoad {
    const inverseDirection = FactoryLayoutService.getInverseDirection(edge.direction);
    return {
      length: edge.length,
      direction: inverseDirection,
      from: edge.to,
      to: edge.from,
    };
  }

  public static getModuleNode(module: Module): ModuleNode {
    return { id: module.serialNumber, module };
  }

  public static getInverseDirection(direction: RoadDirection) {
    switch (direction) {
      case RoadDirection.EAST:
        return RoadDirection.WEST;
      case RoadDirection.WEST:
        return RoadDirection.EAST;
      case RoadDirection.NORTH:
        return RoadDirection.SOUTH;
      case RoadDirection.SOUTH:
        return RoadDirection.NORTH;
    }
  }

  public static findEdgeBetweenNodes(
    edges: FactoryRoad[],
    from: ModuleNode | FactoryNode,
    to: ModuleNode | FactoryNode,
  ): FactoryRoad | undefined {
    return edges.find(edge => {
      const hasSameSource = edge.from.id === from.id;
      const hasSameTarget = edge.to.id === to.id;
      return hasSameSource && hasSameTarget;
    });
  }

  public static isNodeDuplicate(node: ModuleNode | FactoryNode, existingNodes: Array<ModuleNode | FactoryNode>): boolean {
    const foundDuplicate = existingNodes.find(existingNode => existingNode.id === node.id);
    return !!foundDuplicate;
  }

  public static isEdgeDuplicate(edge: FactoryRoad, existingEdges: FactoryRoad[]): boolean {
    const foundDuplicate = existingEdges.find(existingEdge => {
      const hasSameSource = existingEdge.from.id === edge.from.id;
      const hasSameTarget = existingEdge.to.id === edge.to.id;
      return hasSameSource && hasSameTarget;
    });
    return !!foundDuplicate;
  }

  public static get graph(): FactoryGraph {
    return FactoryLayoutService._graph as FactoryGraph;
  }

  public static set graph(graph: FactoryGraph) {
    FactoryLayoutService._graph = graph;
    FactoryLayoutService.logGraph();
  }

  public static destroy(): void {
    FactoryLayoutService._graph = undefined;
    FactoryLayoutService.layout = undefined;
    FactoryLayoutService.blocked_nodes = undefined;
  }

  private static checkIsInitialized(): void {
    console.log(JSON.stringify(FactoryLayoutService.graph, null, 2));
    if (!FactoryLayoutService.graph) {
      throw new Error('FactoryLayout not initialized');
    }
  }

  /**
   * Set a new layout and recreate the graph
   * @param layout
   */
  public static setLayout(layout: FactoryLayout) {
    const modules = PairingStates.getInstance().getAll();
    for (const mod of modules) {
      if (mod.connected && mod.subType && mod.serialNumber) {
        this.replacePlaceholderModuleInLayout(layout, mod.subType, mod.serialNumber);
      }
    }
    const graph = this.generateGraphFromJsonLayout(layout);
    if (graph) {
      // Mark the modules used in the layout as paired
      PairingStates.getInstance().setPairedModules(
        layout.modules.filter(mod => !mod.placeholder && !mod.serialNumber.endsWith('-MISSING')),
      );
      this.layout = layout;
      this.graph = graph;
    }
  }

  /**
   * Reload layout from the configuration and rebuild graph
   */
  public static async reloadLayout() {
    if (this.layout_file) {
      const layout = await this.loadLayoutFromJsonFile(this.layout_file);
      if (layout) {
        this.setLayout(layout);
      }
      if (!layout || !this.layout?.roads.length) {
        await this.loadDefaultLayout();
      }
    }
  }

  /**
   * Save current layout to the configuration file
   */
  public static async saveLayout(): Promise<void> {
    if (this.layout_file) {
      await writeJsonFile(this.layout_file, this.layout);
    }
  }

  /**
   * Publish current layout to MQTT
   */
  public static async publishLayout(): Promise<void> {
    if (this.layout && getMqttClient()) {
      await publishPairingState();
      return getMqttClient().publish(CcuTopic.LAYOUT, JSON.stringify(this.layout), { qos: 1, retain: true });
    }
  }

  private static replacePlaceholderModuleInLayout(layout: FactoryLayout, type: ModuleType, serialNumber: string): boolean {
    const module = layout.modules.find(mod => mod.type === type && mod.placeholder);
    if (module) {
      const placeholderSerial = module.serialNumber;
      module.placeholder = false;
      module.serialNumber = serialNumber;
      for (const road of layout.roads) {
        if (road.to === placeholderSerial) {
          road.to = serialNumber;
        }
        if (road.from === placeholderSerial) {
          road.from = serialNumber;
        }
      }
      return true;
    }
    return false;
  }

  public static async replacePlaceholder(type: ModuleType, serialNumber: string) {
    if (this.replacePlaceholderModuleInLayout(this.layout as FactoryLayout, type, serialNumber)) {
      this.setLayout(this.layout as FactoryLayout);
      await this.saveLayout();
      await this.publishLayout();
    }
  }

  /**
   * Blocks nodes for an FTS so other can not impede its path.
   * If a blocker refers to a missing previous node, the function throws an error and may leave the blocklist in an inconsistent state.
   * If a node has already been blocked by a different FTS, an error is thrown and the blocklist may be in an inconsistent state.
   * If a node has already been blocked by the same FTS with a different preceding node, an error is thrown and the blocklist may be in an inconsistent state.
   * @param blockedNodes
   */
  public static blockNodeSequence(blockedNodes: Array<FactoryNodeBlocker>): void {
    if (config.routing.disableNodeBlocking) {
      console.warn('Node blocking disabled by config. This may lead to a crash if multiple FTS are driving on the layout');
      return;
    }
    console.log('Blocked Nodes before blocking', [...(this.blocked_nodes as Map<string, FactoryNodeBlocker>).values()]);
    for (const blocker of blockedNodes) {
      if (blocker.afterNodeId && !(this.blocked_nodes as Map<string, FactoryNodeBlocker>).get(blocker.afterNodeId)) {
        console.error(`Wrong nodes: `, blocker);
        throw new Error(`Node points to missing preceding node`);
      }

      const oldBlocker = (this.blocked_nodes as Map<string, FactoryNodeBlocker>).get(blocker.nodeId);
      if (oldBlocker) {
        if (oldBlocker.ftsSerialNumber !== blocker.ftsSerialNumber) {
          throw new Error('Node already blocked by another FTS');
        }
        if (oldBlocker.afterNodeId && blocker.afterNodeId && oldBlocker.afterNodeId !== blocker.afterNodeId) {
          console.error(`Different nodes: `, oldBlocker, blocker);
          throw new Error('Node blocked with a different preceding node');
        } else if (!oldBlocker.afterNodeId) {
          oldBlocker.afterNodeId = blocker.afterNodeId;
        }
      } else {
        (this.blocked_nodes as Map<string, FactoryNodeBlocker>).set(blocker.nodeId, blocker);
      }
    }
    console.log('Blocked Nodes', [...(this.blocked_nodes as Map<string, FactoryNodeBlocker>).values()]);
  }

  /**
   * Release nodes that were blocked by the given FTS before the current node.
   * @param ftsSerialNumber
   * @param nodeId
   */
  public static releaseNodesBefore(ftsSerialNumber: string, nodeId: string): void {
    const currentNode = (this.blocked_nodes as Map<string, FactoryNodeBlocker>).get(nodeId);
    if (!currentNode) {
      return;
    }
    let previousNodeId = currentNode.afterNodeId;
    currentNode.afterNodeId = undefined;
    while (previousNodeId) {
      const node = (this.blocked_nodes as Map<string, FactoryNodeBlocker>).get(previousNodeId);
      if (!node || node.ftsSerialNumber !== ftsSerialNumber) {
        return;
      }
      (this.blocked_nodes as Map<string, FactoryNodeBlocker>).delete(previousNodeId);
      previousNodeId = node.afterNodeId;
    }
    console.log('Blocked nodes after release', [...(this.blocked_nodes as Map<string, FactoryNodeBlocker>).values()]);
  }

  /**
   * Releases all nodes that were blocked by an FTS. Most likely used when an FTS is either removed from the
   * APS (e.g. reset was issued) or when the FTS is done driving on the layout and is docked at a module.
   * If no serialNumber is given, all nodes are released.
   * @param ftsSerialNumber The FTS that blocked the nodes
   */
  public static releaseAllNodes(ftsSerialNumber?: string) {
    for (const [nodeId, blocker] of (this.blocked_nodes as Map<string, FactoryNodeBlocker>).entries()) {
      if (ftsSerialNumber == null || blocker.ftsSerialNumber === ftsSerialNumber) {
        (this.blocked_nodes as Map<string, FactoryNodeBlocker>).delete(nodeId);
      }
    }
  }
  /**
   * Releases all nodes that were blocked by an FTS.
   * @param ftsSerialNumber
   * @param nodeId to keep blocked
   */
  public static releaseAllNodesExcept(ftsSerialNumber: string, nodeId: string) {
    this.releaseAllNodes(ftsSerialNumber);
    this.blockNodeSequence([{ nodeId: nodeId, ftsSerialNumber: ftsSerialNumber }]);
  }

  /**
   * Check if a node is currently blocked.
   * If an FTS is given, then treat nodes blocked by it as available
   * @param nodeId
   * @param ftsSerialNumber
   */
  public static isNodeBlocked(nodeId: string, ftsSerialNumber?: string): boolean {
    const node = (this.blocked_nodes as Map<string, FactoryNodeBlocker>).get(nodeId);
    return !!node && (!ftsSerialNumber || node.ftsSerialNumber !== ftsSerialNumber);
  }

  /**
   * List all blocked nodes.
   * If an FTS is given, then treat nodes blocked by it as available
   * @param [ftsSerialNumber]
   */
  public static getBlockedNodeIds(ftsSerialNumber?: string): Set<string> {
    if (!ftsSerialNumber) {
      return new Set((this.blocked_nodes as Map<string, FactoryNodeBlocker>).keys());
    }
    console.log('--> BLOCKED NODES: ', JSON.stringify(Object.fromEntries(this.blocked_nodes as Map<string, FactoryNodeBlocker>), null, 2));
    const blocked = [...(this.blocked_nodes as Map<string, FactoryNodeBlocker>).values()].filter(
      block => block.ftsSerialNumber !== ftsSerialNumber,
    );
    return new Set(blocked.map(block => block.nodeId));
  }
}
