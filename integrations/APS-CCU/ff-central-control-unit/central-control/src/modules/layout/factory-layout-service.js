"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FactoryLayoutService = void 0;
const protocol_1 = require("../../../../common/protocol");
const ccu_1 = require("../../../../common/protocol/ccu");
const config_1 = __importDefault(require("../../config"));
const helpers_1 = require("../../helpers");
const mqtt_1 = require("../../mqtt/mqtt");
const pairing_1 = require("../pairing");
const pairing_states_1 = require("../pairing/pairing-states");
const default_layout_1 = require("./default_reset/default_layout");
/**
 * Responsible for managing the layout of the future factory.
 * This includes persisting changes to the layout and providing a graph representation of the layout.
 * {@link NavigatorService} uses this graph to determine the path between two modules which can be used to
 * drive the FTS.
 */
class FactoryLayoutService {
    /**
     * This method is supposed to be called in the initial startup routine of the CCU before
     * any orders are processed or generated by the CCU (i.e. before the MQTT connection is established)
     *
     * @param [filename] Filename for persistent graph storage, use memory when undefined.
     */
    static async initialize(filename) {
        console.debug('Initialize the Factory Layout Service');
        if (this._graph) {
            throw new Error('FactoryLayout already initialized');
        }
        console.log('Factory Graph initialized');
        this.blocked_nodes = new Map();
        FactoryLayoutService.graph = FactoryLayoutService.getEmptyGraph();
        this.layout = FactoryLayoutService.getEmptyLayout();
        if (filename) {
            console.debug(`PERSISTENCE: Loading and saving layout from ${filename}`);
            this.layout_file = filename;
            await this.reloadLayout();
        }
        else {
            await this.loadDefaultLayout();
        }
        console.debug('Factory Layout Service ready');
    }
    static getEmptyGraph() {
        return {
            nodes: [],
            edges: [],
        };
    }
    static getEmptyLayout() {
        return {
            modules: [],
            intersections: [],
            roads: [],
        };
    }
    static async loadDefaultLayout() {
        const layout = JSON.parse(JSON.stringify(default_layout_1.DEFAULT_LAYOUT));
        this.setLayout(layout);
        await this.publishLayout();
    }
    static async resetToDefaultLayout() {
        await this.loadDefaultLayout();
        await this.saveLayout();
    }
    static logGraph() {
        FactoryLayoutService.checkIsInitialized();
        console.debug(JSON.stringify(FactoryLayoutService.graph, null, 2));
    }
    /**
     * TODO: Maybe we want to extend this to a new interface "plate" which represents an actual ground plate of the ff
     * Based on the input modules, intersections and edges, this method generates a graph representation of the factory layout.
     *
     * This implementation automatically inserts the inverse roads in the graph.
     *
     * @param modules
     * @param intersections
     * @param edges
     */
    static generateGraph(modules, intersections, edges) {
        const generatedGraph = FactoryLayoutService.getEmptyGraph();
        modules.forEach(module => {
            const moduleNode = FactoryLayoutService.getModuleNode(module);
            if (FactoryLayoutService.isNodeDuplicate(moduleNode, generatedGraph.nodes)) {
                throw Error(`Node ${JSON.stringify(moduleNode)} already exists`);
            }
            console.log('Adding module node', moduleNode);
            generatedGraph.nodes.push(moduleNode);
        });
        intersections.forEach(intersection => {
            if (FactoryLayoutService.isNodeDuplicate(intersection, generatedGraph.nodes)) {
                throw Error(`Node ${JSON.stringify(intersection)} already exists`);
            }
            console.log('Adding intersection', intersection);
            generatedGraph.nodes.push(intersection);
        });
        edges.forEach(edge => {
            console.log('Checking duplicate', edge);
            if (FactoryLayoutService.isEdgeDuplicate(edge, generatedGraph.edges)) {
                throw Error(`Edge from ${JSON.stringify(edge.from)} to ${JSON.stringify(edge.to)} already exists`);
            }
            console.log('Adding edge', edge);
            generatedGraph.edges.push(edge);
        });
        // Add inverse edges
        console.log('ADDING INVERSE EDGES');
        const inverseEdges = [];
        generatedGraph.edges.forEach(edge => {
            // Add inverse edge
            const inverseEdge = FactoryLayoutService.getInverseEdge(edge);
            console.log('Checking inverse duplicate', inverseEdge);
            if (FactoryLayoutService.isEdgeDuplicate(inverseEdge, generatedGraph.edges)) {
                throw Error(`Inverse edge from ${JSON.stringify(inverseEdge.from)} to ${JSON.stringify(inverseEdge.to)} already exists`);
            }
            console.log('Adding inverse edge', inverseEdge);
            inverseEdges.push(inverseEdge);
        });
        generatedGraph.edges.push(...inverseEdges);
        return generatedGraph;
    }
    /**
     * Load a factory layout from modules, intersections and edges in a json file
     *
     * @param filepath The location of the layout file
     * @return the layout or null if it cannot be loaded
     */
    static async loadLayoutFromJsonFile(filepath) {
        try {
            const layout = await (0, helpers_1.readJsonFile)(filepath);
            if ('roads' in layout && 'modules' in layout && 'intersections' in layout) {
                return layout;
            }
            else {
                console.error('Invalid json object for factory layout.');
            }
        }
        catch (e) {
            console.error('Error while loading json layout:', e);
        }
        return null;
    }
    /**
     * Generate the factory graph based on the layout object
     *
     * This implementation automatically inserts the inverse roads in the graph.
     *
     * @param {FactoryLayout} layout The flat factory layout
     */
    static generateGraphFromJsonLayout(layout) {
        const getNodeForId = (id) => {
            const intersection = layout.intersections.find(node => node.id === id);
            if (intersection) {
                return intersection;
            }
            const module = layout.modules.find(mod => mod.serialNumber === id);
            if (module) {
                return FactoryLayoutService.getModuleNode(module);
            }
            return undefined;
        };
        const roads = layout.roads
            .map(road => {
            return {
                direction: road.direction,
                length: road.length,
                from: getNodeForId(road.from),
                to: getNodeForId(road.to),
            };
        })
            .filter((road) => !!road.from && !!road.to);
        return FactoryLayoutService.generateGraph(layout.modules, layout.intersections, roads);
    }
    /**
     * Duplicates a directed edge to have its inverse:
     * - start and target node are switched
     * - the direction is inversed (e.g. NORTH -> SOUTH)
     * Used to generate all inverse edges to reduce setup boilderplating
     * This method assumes, all edges are directed but have an inverse edge for the way backwards
     * @param edge The edge to inverse
     */
    static getInverseEdge(edge) {
        const inverseDirection = FactoryLayoutService.getInverseDirection(edge.direction);
        return {
            length: edge.length,
            direction: inverseDirection,
            from: edge.to,
            to: edge.from,
        };
    }
    static getModuleNode(module) {
        return { id: module.serialNumber, module };
    }
    static getInverseDirection(direction) {
        switch (direction) {
            case ccu_1.RoadDirection.EAST:
                return ccu_1.RoadDirection.WEST;
            case ccu_1.RoadDirection.WEST:
                return ccu_1.RoadDirection.EAST;
            case ccu_1.RoadDirection.NORTH:
                return ccu_1.RoadDirection.SOUTH;
            case ccu_1.RoadDirection.SOUTH:
                return ccu_1.RoadDirection.NORTH;
        }
    }
    static findEdgeBetweenNodes(edges, from, to) {
        return edges.find(edge => {
            const hasSameSource = edge.from.id === from.id;
            const hasSameTarget = edge.to.id === to.id;
            return hasSameSource && hasSameTarget;
        });
    }
    static isNodeDuplicate(node, existingNodes) {
        const foundDuplicate = existingNodes.find(existingNode => existingNode.id === node.id);
        return !!foundDuplicate;
    }
    static isEdgeDuplicate(edge, existingEdges) {
        const foundDuplicate = existingEdges.find(existingEdge => {
            const hasSameSource = existingEdge.from.id === edge.from.id;
            const hasSameTarget = existingEdge.to.id === edge.to.id;
            return hasSameSource && hasSameTarget;
        });
        return !!foundDuplicate;
    }
    static get graph() {
        return FactoryLayoutService._graph;
    }
    static set graph(graph) {
        FactoryLayoutService._graph = graph;
        FactoryLayoutService.logGraph();
    }
    static destroy() {
        FactoryLayoutService._graph = undefined;
        FactoryLayoutService.layout = undefined;
        FactoryLayoutService.blocked_nodes = undefined;
    }
    static checkIsInitialized() {
        console.log(JSON.stringify(FactoryLayoutService.graph, null, 2));
        if (!FactoryLayoutService.graph) {
            throw new Error('FactoryLayout not initialized');
        }
    }
    /**
     * Set a new layout and recreate the graph
     * @param layout
     */
    static setLayout(layout) {
        const modules = pairing_states_1.PairingStates.getInstance().getAll();
        for (const mod of modules) {
            if (mod.connected && mod.subType && mod.serialNumber) {
                this.replacePlaceholderModuleInLayout(layout, mod.subType, mod.serialNumber);
            }
        }
        const graph = this.generateGraphFromJsonLayout(layout);
        if (graph) {
            // Mark the modules used in the layout as paired
            pairing_states_1.PairingStates.getInstance().setPairedModules(layout.modules.filter(mod => !mod.placeholder && !mod.serialNumber.endsWith('-MISSING')));
            this.layout = layout;
            this.graph = graph;
        }
    }
    /**
     * Reload layout from the configuration and rebuild graph
     */
    static async reloadLayout() {
        if (this.layout_file) {
            const layout = await this.loadLayoutFromJsonFile(this.layout_file);
            if (layout) {
                this.setLayout(layout);
            }
            if (!layout || !this.layout?.roads.length) {
                await this.loadDefaultLayout();
            }
        }
    }
    /**
     * Save current layout to the configuration file
     */
    static async saveLayout() {
        if (this.layout_file) {
            await (0, helpers_1.writeJsonFile)(this.layout_file, this.layout);
        }
    }
    /**
     * Publish current layout to MQTT
     */
    static async publishLayout() {
        if (this.layout && (0, mqtt_1.getMqttClient)()) {
            await (0, pairing_1.publishPairingState)();
            return (0, mqtt_1.getMqttClient)().publish(protocol_1.CcuTopic.LAYOUT, JSON.stringify(this.layout), { qos: 1, retain: true });
        }
    }
    static replacePlaceholderModuleInLayout(layout, type, serialNumber) {
        const module = layout.modules.find(mod => mod.type === type && mod.placeholder);
        if (module) {
            const placeholderSerial = module.serialNumber;
            module.placeholder = false;
            module.serialNumber = serialNumber;
            for (const road of layout.roads) {
                if (road.to === placeholderSerial) {
                    road.to = serialNumber;
                }
                if (road.from === placeholderSerial) {
                    road.from = serialNumber;
                }
            }
            return true;
        }
        return false;
    }
    static async replacePlaceholder(type, serialNumber) {
        if (this.replacePlaceholderModuleInLayout(this.layout, type, serialNumber)) {
            this.setLayout(this.layout);
            await this.saveLayout();
            await this.publishLayout();
        }
    }
    /**
     * Blocks nodes for an FTS so other can not impede its path.
     * If a blocker refers to a missing previous node, the function throws an error and may leave the blocklist in an inconsistent state.
     * If a node has already been blocked by a different FTS, an error is thrown and the blocklist may be in an inconsistent state.
     * If a node has already been blocked by the same FTS with a different preceding node, an error is thrown and the blocklist may be in an inconsistent state.
     * @param blockedNodes
     */
    static blockNodeSequence(blockedNodes) {
        if (config_1.default.routing.disableNodeBlocking) {
            console.warn('Node blocking disabled by config. This may lead to a crash if multiple FTS are driving on the layout');
            return;
        }
        console.log('Blocked Nodes before blocking', [...this.blocked_nodes.values()]);
        for (const blocker of blockedNodes) {
            if (blocker.afterNodeId && !this.blocked_nodes.get(blocker.afterNodeId)) {
                console.error(`Wrong nodes: `, blocker);
                throw new Error(`Node points to missing preceding node`);
            }
            const oldBlocker = this.blocked_nodes.get(blocker.nodeId);
            if (oldBlocker) {
                if (oldBlocker.ftsSerialNumber !== blocker.ftsSerialNumber) {
                    throw new Error('Node already blocked by another FTS');
                }
                if (oldBlocker.afterNodeId && blocker.afterNodeId && oldBlocker.afterNodeId !== blocker.afterNodeId) {
                    console.error(`Different nodes: `, oldBlocker, blocker);
                    throw new Error('Node blocked with a different preceding node');
                }
                else if (!oldBlocker.afterNodeId) {
                    oldBlocker.afterNodeId = blocker.afterNodeId;
                }
            }
            else {
                this.blocked_nodes.set(blocker.nodeId, blocker);
            }
        }
        console.log('Blocked Nodes', [...this.blocked_nodes.values()]);
    }
    /**
     * Release nodes that were blocked by the given FTS before the current node.
     * @param ftsSerialNumber
     * @param nodeId
     */
    static releaseNodesBefore(ftsSerialNumber, nodeId) {
        const currentNode = this.blocked_nodes.get(nodeId);
        if (!currentNode) {
            return;
        }
        let previousNodeId = currentNode.afterNodeId;
        currentNode.afterNodeId = undefined;
        while (previousNodeId) {
            const node = this.blocked_nodes.get(previousNodeId);
            if (!node || node.ftsSerialNumber !== ftsSerialNumber) {
                return;
            }
            this.blocked_nodes.delete(previousNodeId);
            previousNodeId = node.afterNodeId;
        }
        console.log('Blocked nodes after release', [...this.blocked_nodes.values()]);
    }
    /**
     * Releases all nodes that were blocked by an FTS. Most likely used when an FTS is either removed from the
     * APS (e.g. reset was issued) or when the FTS is done driving on the layout and is docked at a module.
     * If no serialNumber is given, all nodes are released.
     * @param ftsSerialNumber The FTS that blocked the nodes
     */
    static releaseAllNodes(ftsSerialNumber) {
        for (const [nodeId, blocker] of this.blocked_nodes.entries()) {
            if (ftsSerialNumber == null || blocker.ftsSerialNumber === ftsSerialNumber) {
                this.blocked_nodes.delete(nodeId);
            }
        }
    }
    /**
     * Releases all nodes that were blocked by an FTS.
     * @param ftsSerialNumber
     * @param nodeId to keep blocked
     */
    static releaseAllNodesExcept(ftsSerialNumber, nodeId) {
        this.releaseAllNodes(ftsSerialNumber);
        this.blockNodeSequence([{ nodeId: nodeId, ftsSerialNumber: ftsSerialNumber }]);
    }
    /**
     * Check if a node is currently blocked.
     * If an FTS is given, then treat nodes blocked by it as available
     * @param nodeId
     * @param ftsSerialNumber
     */
    static isNodeBlocked(nodeId, ftsSerialNumber) {
        const node = this.blocked_nodes.get(nodeId);
        return !!node && (!ftsSerialNumber || node.ftsSerialNumber !== ftsSerialNumber);
    }
    /**
     * List all blocked nodes.
     * If an FTS is given, then treat nodes blocked by it as available
     * @param [ftsSerialNumber]
     */
    static getBlockedNodeIds(ftsSerialNumber) {
        if (!ftsSerialNumber) {
            return new Set(this.blocked_nodes.keys());
        }
        console.log('--> BLOCKED NODES: ', JSON.stringify(Object.fromEntries(this.blocked_nodes), null, 2));
        const blocked = [...this.blocked_nodes.values()].filter(block => block.ftsSerialNumber !== ftsSerialNumber);
        return new Set(blocked.map(block => block.nodeId));
    }
}
exports.FactoryLayoutService = FactoryLayoutService;
